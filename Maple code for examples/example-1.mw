<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="18" minor="0"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true">
</View-Properties>
<MapleNet-Properties elisiondigitsbefore="100" labelling="true" indentamount="4" elisiontermsthreshold="10000" ansi="false" errorbreak="1" useclientjvm="true" echo="1" imaginaryunit="I" labelwidth="20" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" contextmenusize="automatic" plotdriver="opengl" elisiondigitsafter="100" plotoutput="terminal" helpbrowser="standard" rtablesize="10" elisiontermsbefore="100" elisiondigitsthreshold="10000" typesetting="standard" plotdevice="inline" verboseproc="1" showassumed="1" quiet="false" errorcursor="false" longdelim="true" plotoptions="" elisiontermsafter="100" screenwidth="79" preplot="" prettyprint="3" displayprecision="-1" screenpixelheight="1080" warnlevel="3" screenheight="25" latexwidth="8.0" postplot="" prompt="&gt; " ShowLabels="true"/>
<Styles>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Maple Name" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[104,64,92]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Menus" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Fixed Width" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Plot Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="8" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Nonterminal" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Heading" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Italic Bold" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Default" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Underlined Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output12" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Times New Roman" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math Bold Small" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Small" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Page Number" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Output Labels" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="8" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Plot Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Emphasized" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Symbol 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Comment" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="SimSun" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Italic Small203" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output6" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[64,128,64]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="SimSun" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Italic Small" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Comment" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Underlined Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Copyright" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Help Underlined" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Prompt" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Notes" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="LaTeX" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Popup" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="SimSun" foreground="[175,0,175]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="SimSun" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Left Justified Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Fixed" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Ordered List 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="none" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 3" alignment="left" bullet="none" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 4" alignment="left" bullet="none" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 5" alignment="left" bullet="none" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Fixed Width" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Text Output6" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Help" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output12" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Left Justified Maple Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
</Styles>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group labelreference="L2" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX#
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX#
#  TORIC RESULTANTS
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX#
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX#
# Maple9 code for sparse (toric) resultant matrices.
# Author: Ioannis Z Emiris, National Univ. of Athens, Greece
# emiris@di.uoa.gr, http://www.di.uoa.gr/~emiris/
# Originally based on code by John Canny and Paul Pedersen in 1993.
# File created 10/03 from spares8.mpl, adding RATIONAL_FORMULA feature.
# This is software under development, and is free for distribution.
# The author assumes no responsibility, but comments are welcome.

# Created: 5/96
# Last update: 3/2004

# Main function call:
# spresultant(polynomial_list, eliminated_variable_list,
#        [,geometric_perturbation_vector [,lifting_matrix]] ) 
#        RETURNS sparse (toric) resultant matrix in input coefficients

# References:
# For the subdivision-based algorithm: J.F. Canny and I.Z. Emiris,
# &quot;An efficient algorithm for the sparse mixed resultant&quot;, in Proc.
# AAECC-93.  Final version: &quot;A Subdivision-Based Algorithm for the
# Sparse Resultant&quot;, J. ACM, 47:417-451, 2000.
 
with(simplex):
with(linalg):
readlib(unassign):
RATIONAL_FORMULA := 0;          # 1 iff denominator matrix computed

############# utilities #####################

RandSign := proc() eval(eval(rand(0..1)())*2-1) end:

# Return true/false depending on whether 'tarray' is an array.
#   For 1-dimensional arrays (vectors) check whether its elements
#   are of type 'ttype' and return true/false accordingly.
#
`toric/type1Array` := proc(tarray::array,ttype::name)
  local i, size;
  if not type(tarray,vector) then RETURN(true); fi;        
  # else 1-dim array ie. vector and will check elements
  size := nops(convert(tarray,list));
  for i from 1 to size do
    if (not(evalb(type(tarray[i],ttype)))) then RETURN(false); fi;
  od;
  RETURN(true);
end:        # `toric/type1Array`

# computes the 2-norm of a vector expressed as (1Xn) matrix
#
`toric/twonorm` := proc(x::matrix)
  local i,r;
    r := x[1,1]^2;
    for i from 2 to coldim(x) do r := r + x[1,i]^2 od;
    convert(sqrt(r), float)
end: # `toric/twonorm`

# checks if &quot;el&quot; lies in the set or list &quot;vset&quot;, using equal rather than =
#
`toric/vmem` := proc(el, vset)
  local found, el2;
  found := false;
  for el2 in vset do
    if equal(el, el2) then found := true; break fi;
  od;
  found;
end: # `toric/vmem`

# define a random affine functional as a random dxd matrix
# To be used for lifting and defining mixed subdivision
#
`toric/randaff` := proc(d::integer)
  local i,j,l,die;
  die := rand(1..1000);
  l := matrix(d,d);
  for i from 1 to d do
    for j from 1 to d do l[i,j] := die() od;
  od;
  eval(l);
end: # `toric/randaff`

# random integer vector of length n
# To be used as displacement (perturbation) of Minkowski sum
#
`toric/randvect` := proc(n::integer)
  local i, rproc, sgn, r;
  rproc := rand(1..1000);
  sgn := rand(1..2);
  r := array(1..n);

  for i to n do
    r[i] := convert(rproc()/10000, float);
    if sgn()=1 then r[i] := -r[i]; fi
  od;
  eval(r);
end: # `toric/randvect`

# computes Center Of Gravity of Newton polytope
# hull=arr[d,#monoms.in.hull], exponents are columns
# returns matrix[#monoms,1]
#
`toric/cog` := proc(hull::array)
  local numonom, v;
  numonom := coldim(hull);
  v := multiply(hull, convert(vector(numonom,1), matrix));
  scalarmul(v, 1/numonom);
end: # `toric/cog`

################### polynomial operations ################

## HELP `toric/coefofexp`
##
## `toric/coefofexp` - monomial coefficient in a polynomial.
##
## CALLING SEQUENCE:
##     `toric/coefofexp`(p, v, d)
##
## PARAMETERS:
##     p  - polynomial
##     v  - array of variables
##     d  - array of integers
## DESCRIPTION:
## - Compute the coefficient of p corresponding to v^d.  
##   Arrays v and d must be 1-dimensional and of the same size.
##
## EXAMPLES:
##&gt; `toric/coefofexp`(x^2-y*z+y*x-1,array(1..3,[x,y,z]),array(1..3,[0,1,1]));
##
##                              -1
##
##&gt; `toric/coefofexp`(x^2-y*z+y*x-1,array(1..3,[x,y,z]),array(1..3,[1,0,2]));
##
##                              0
## SEE ALSO:
## coeffs
##
`toric/coefofexp` := proc(p::polynom, v::array, d::array)
  local i, ans, sz;
  if (not(evalb(`toric/type1Array`(v,name)))) then
    ERROR(`Coeffofmon requires second argument`,v,`be an array of names`);
  fi;
  if (not(evalb(`toric/type1Array`(d,integer)))) then
    ERROR(`Coeffofmon requires third argument`, d,`be an array of ints`);
  fi;

  sz := nops(convert(d,list));
  if (not(evalb(nops(convert(v,list))=sz))) then
    ERROR(`Coeffofmon requires size(variables)=size(degrees)`);
  fi;

  ans := p;
  for i from 1 to sz do
    ans := coeff(ans,v[i],d[i]);
  od;

  RETURN(eval(ans));

end:    # `toric/coefofexp`

# map a function 'fnc' on all coefficients of polynomial 'poly'
# return the new polynomial
#
`toric/map_coefs` := proc (fnc,poly::polynom)
  local cvec, mvec, mons;
  cvec := vector(map(fnc,[coeffs(expand(poly),indets(expand(poly)),'mons')]));
  mvec := vector([mons]);
  # lprint(`map_coef_returns`,dotprod (cvec, mvec, 'orthogonal'));
  dotprod (cvec, mvec, 'orthogonal');
end:         # `toric/map_coefs`

#################### format conversion #############################
#----------------------------------------------------------------------
addtohelp(`toric/polytope`):
#---------------------------------------------------------------------- 
## HELP `toric/polytope`
##
## `toric/polytope` - compute Newton polytopes and supports of polynomial system
##
## CALLING SEQUENCE:
##     `toric/polytope`(pol, var)
##
## PARAMETERS:
##     pol  - list of polynomials
##     var  - list of variables
## DESCRIPTION:
## - Compute the Newton polytopes and supports of the given polynomial
##   system &quot;pol&quot; with respect to the variables &quot;var&quot;.
##
## - The function returns a sequence of two arrays: one for the Newton
##   polytope vertices (indexing into the supports) and one for the supports.
##
## EXAMPLES:
##&gt; `toric/polytope`([x^2-x+y*x-1,x*y-3,2*x-x*y-1],[x,y]);
##
##                                        [[0   1   2   1]  [0   1]  [0   1   1]]
## [{1, 3, 4}, {1, 2}, {1, 2, 3}], [[             ], [     ], [         ]]
##                                   [[0   0   0   1]  [0   1]  [0   0   1]]
##
## SEE ALSO:
## `toric/mixed`, spresultant
##
`toric/polytope` := proc (pol::list, var::list)
local polylist, varlist, apol, npols, supps, hulls;

  polylist := convert(pol,list);
  varlist := convert(var,list);

  npols := nops(polylist);
<Font encoding="UTF-8">  # printf(&quot;working on %d polynomials in %d variables\134n&quot;,npols,nops(varlist));
</Font>
  supps := array (1..npols);
  hulls := array (1..npols);

  # printf(&quot;Newton polytope vertex cardinalities are&quot;);
  for apol from 1 to npols do
    supps[apol] := `toric/supp_mat` (polylist[apol], varlist);                # mat[dim,num]
    hulls[apol] := `toric/comp_hull` (supps[apol], 2*nops(varlist));        # 2 = arbitrary
    # printf(&quot;, %d&quot;,nops(hulls[apol]));
  od;
<Font encoding="UTF-8">  # printf(&quot;.\134n&quot;);
</Font>
  RETURN (eval(hulls), eval(supps));
end:        # `toric/polytope`

# in_poly = input polynomial
# vars = list of variables to be eliminated (after hiding)
# return the support of &quot;in_poly&quot; as num_vars x num_monoms matrix
#
`toric/supp_mat` := proc (in_poly::polynom, vars::list)
  local v, nvars,
        poly, supp,
        mons, monl,
        m, nmons;
  # lprint(`got polyn`,in_poly,`in vars`,vars);
  poly := collect(simplify (expand(in_poly)), vars, distributed);
  coeffs( eval(poly), vars, 'mons');
  # lprint(`put monoms in`,mons);

  monl := sort([mons]);
  nmons := nops(monl);
  # lprint(`collected polyn`,poly,`w/monoms`,monl);

  nvars := nops (vars);
  supp := matrix (nvars, nmons);

  for m from 1 to nmons do
    for v from 1 to nvars do supp[v,m] := degree (monl[m], vars[v]); od;
  od;        # for monomial

  evalm (supp);
end:        # `toric/supp_mat`

# polyn = polynomial in any variables
# return polynomial multiplied by min. int to get rid of denominators
#   so that max abs.value of new coeffs doesnt exceed local bound
#
`toric/scaled` := proc (polyn::polynom)
  local coefs, c,                        # all Numeric coefficients
        mx, mult,                        # max coef, denominator multiplier
        too_big_constant;
  too_big_constant := 2^30;

  coefs := coeffs (collect(expand(polyn),indets(polyn),distributed));
  mx := max(op(map(abs,[coefs])));

  mult := 1;
  for c in coefs do if not type(c,integer) then
    c := convert(c,rational,exact);
    mult := ilcm (mult, denom(c));
  fi; od;
  if evalf(abs(mult*mx)) &gt;= too_big_constant then
    mult := max(1, floor( too_big_constant/mx ));
  else # lprint(`multiplying by _lcm_ of denoms=`,mult);
  fi;
  eval(mult * polyn);
end:  # `toric/scaled`

################## matrix construction #####################

# A = array of matrices, each contains vertices as columns.
# alift = lifting: either lifD x lifD matrix or list of lifD lists
#        If matrix, expresses (random) affine lift; rows correspond to polytopes.
#        Historical: also handle lifD x (lifD-1) matrices, expressing linear liftings.
#        If list of lists, each list contains lift.value of resp. supp.point
# lifD = length of A = dimension - 1.
#
# Constructs the following input equations for LP package:
<Font encoding="UTF-8">#   \134lambda_{i,j} are defined to be the LP variables
#   vertex eqts lhs   = \134sum_{ij} \134lambda_{ij} A_{ij}
#   convexity constr. = \134sum \134lambda_{i,j} = 1
</Font># If alift = matrix, then
#   l_i = alift_i = random affine functional, l_i[const] = 0 iff lin.functional
<Font encoding="UTF-8">#   objective         = \134sum_i l_i * ( \134sum_j \134lambda_{i,j} A_{i,j} ) + l_i[const]
</Font># If alift = list of lists, then
<Font encoding="UTF-8">#   objective         = \134sum_i \134sum_j \134lambda_{i,j} * alift[i][j]
</Font>#
`toric/make_eqns` := proc(A::array, alift, lifD::integer)
  local i, j, C, cd, conveq, convsum,
        ipoly, lambda, nverts, objective, vertlhs, linpart;

  objective := 0;                        # objective function
  vertlhs := vector(lifD-1, 0);                # left hand sides vertex equations
  conveq := {};                                # convexity constraints
  nverts := dotprod(vector(lifD,1), map(coldim, A));# total number of vertices

  if type(alift,matrix) then
    linpart := submatrix (alift, 1..lifD, 1..(lifD-1));
  fi;

  for i from 1 to lifD do
        ipoly := A[i];
        convsum := 0;
        cd := coldim(ipoly);
        lambda := array(1..cd);                        # vector of new variables

        for j from 1 to cd do
            lambda[j] := `lam`||i||`x`||j;
            convsum := convsum + lambda[j];
        od;
 
        conveq := conveq union {convsum = 1};
        C := multiply(ipoly, lambda);
        vertlhs := matadd(vertlhs, C);
 
              if type(alift,matrix) then
          objective := objective + multiply (subvector(linpart,i,1..(lifD-1)),C); 
              if coldim(alift)=lifD then objective := objective + alift[i,lifD] fi;
        else
          objective := objective + dotprod (lambda,convert(op(i,alift),vector));
        fi;
  od;

  # print([objective, conveq, eval(vertlhs), nverts]);
  [objective, conveq, vertlhs, nverts];
end: # `toric/make_eqns`

# Input: oldvec = vector w/entries in {-1,0,1}, expresses assignment.
# Output: lex-next higher assignment; skips 0-vector
# 
`toric/incr3asg` := proc (oldvec::vector)
  local i, k, dim, lis;
  lis := convert(oldvec,list);
  dim := nops(lis);

  k := dim; 
  while lis[k] = 1 do k:=k-1 od;
  lis[k] := lis[k]+1;
  for i from k+1 to dim do lis[i] := -1 od;

  if equal(convert(lis,vector),vector(dim,0)) then
    lis[dim] := 1;
  fi;
  
  eval(convert(lis,vector));
end:        # `toric/incr3asg`

# Input:
#   hullArr expresses Newton polytopes
#   lifD = dimension of lifted space = number of polytopes
#   edata = list of objects for linear optimizationS
#   delta = vector of geometric perturbation
# Return:
#   Integer point guaranteed to lie inside perturbed Mink.sum
#   ie. it is vertex in perturbed lifted M.sum.  The last optimization
#   returns info that can be used later but for now it is wasted.
#
`toric/start_vertex` := proc (hullArr::array, lifD::integer, edata::list, delta::vector)
  local i,
        asg, count_asg,
        imax, overts,
        init_v,                         # sum of cog's
        ivt;                                # rounded point

    # init_v := `toric/cog`(hullArr[1]);                # start at center of gravity...
    init_v := eval(submatrix(hullArr[1],1..(lifD-1),[1]));
    for i from 2 to lifD do                                # ... of Minkowski sum
      # init_v := matadd(init_v,`toric/cog`(hullArr[i]))  # =mat[rowdim,1]=[(d-1),1]
      init_v := matadd(init_v,submatrix(hullArr[i],1..(lifD-1),[1]));
    od;
    init_v := map(round,init_v);

    ivt := eval(init_v);                        # (lifD-1)x1 matrix
    imax := 0;
    asg := vector(lifD-1,-1);
    count_asg := 1;

    while imax = 0 do
      # print(`Start point candidate`,eval(ivt));
      overts := `toric/opt_verts`(edata, matadd(ivt,delta,1,-1), lifD);        # lower hull vertex
      imax := lifD;
      while imax&gt;0 and overts[imax]=0 do imax:=imax-1 od;
      if imax=0 then
        # print(`reject with opt.verts`,overts);
        ivt := matadd(init_v,asg,1,1);
        count_asg := count_asg + 1;                                # asg to be comp'd
        if count_asg &gt; 3^(lifD-1) then
                ERROR(`cant find valid starting point after`,count_asg,`tries`) fi;
        asg := `toric/incr3asg` (asg);
      fi;
    od; # while
    eval(ivt);
end:        # `toric/start_vertex`

# must turn `lamMxN` into list [M, N]
#
`toric/recode` := proc(z0)
  local i, L, M, N, s, state, z,
        char0, char1, char2, char3, char4,
        char5, char6, char7, char8, char9;
  for i from 0 to 9 do `char`||`i` := i; od;
  z := convert(z0,string);
  L := length(z);
  M := 0;
  N := 0;
  state := 1;
  for i from 4 to L do
    s := substring(z,i..i);
    if s = &quot;x&quot; then state := 2 fi;
    if state = 1 then M := 10*M + `char`||s;                # for decimals
    elif state = 2 then state := 3;
    elif state = 3 then N := 10*N + `char`||s; fi;
  od;
  [M, N];
end:                # `toric/recode`

# Check which polytope points contribute to optimum sum for vert.
# Input:
#   edata = list of objects including equations from `toric/make_eqns`(),
#   vert  = vertex in Minkowski sum,
#   lifD  = dimension + 1 = number of polynomials.
# Return:
#   optverts = lifD-dim vector, where lifD=n+1
#   optverts[i] = summand vertex of support i, 0 if no vertex from polytope i
#
`toric/opt_verts` := proc(edata::list, vert, lifD::integer)
  local        assigns, eqns, ivert, j, nverts, objective,
        optverts, optvtx,
        verteq, vertlhs, a,
         epsilon, start_timer;
  global tot_time_lp;

  epsilon := 10^(-round(2*Digits/3));

   # Pick apart input from `toric/make_eqns`()
    objective := op(1, edata);                # objective function
    eqns := op(2, edata);                # convexity constraints
    vertlhs := op(3, edata);                # vertex eqns left hand sides
    nverts := op(4, edata);                # total number of input vertices

   # Run LP package to find optimal sum (on lower envelope) for vert
    for j to lifD-1 do
        eqns := eqns union {vertlhs[j] = vert[j,1]}
    od;
<Font encoding="UTF-8">     printf(&quot;Calling minimize() with: lifD=%d, Opt_verts=%a\134n&quot;,lifD,eval(vert));
     printf(&quot;   obj.fnc=%a, eqns=%a\134n&quot;,eval(objective),eval(eqns));
</Font>
    start_timer := time();
    assigns := minimize(objective, eqns, NONNEGATIVE);
    tot_time_lp := tot_time_lp + time() - start_timer;

    if assigns=NULL then ERROR(`unbounded`);
    # elif assigns={} then ERROR(`infeasible`); 
    fi;
     print(`obtained`,assigns);

   # find vertices appearing in the representation
    optverts := vector(lifD,0);                        # unset

    for a in assigns do
        if (abs(rhs(a)-1.0) &lt; epsilon) then
            optvtx := `toric/recode`(lhs(a));                # list [pol,mon]
            if optverts[optvtx[1]]&gt;0 then ERROR(`optimal vertex already assigned`) fi;
            optverts[optvtx[1]] := optvtx[2];
        fi
    od;   
    optverts;
end:                         # `toric/opt_verts`

# greedy / std algorithm for finding rows of sparse (toric) resultant matrix
#
# H          = c. hulls: arrays of arrays ((lifD-1) X num vertices) of input vertices
# S      = supports: arrays of arrays of input vertices plus interior points
# edata  = equations defining lower hull suitable for simplex package
# init_v = vtx in Mink.sum of the H[i], coldim x 1 matrix, iff greedy algo;
#           std algo iff init_v = all pts in Mink.sum = superset of matrix indices
# delta  = random small displacement vector
# lifD   = dimension + 1 = lifted dimension = Number of polynomials
# trace  = debug/message level during execution.  0 for silence
#
# Returns sorted list &quot;guide&quot; indexing the matrix rows as polyn*monom products.
# Each row coded as list [ pt in Mink.sum, polynomial indx, monom in its support ]
#         so that the support pt (or monom) w/max polyn.index appears
#        in the optimal sum expressing the Mink.sum point.
#
<Font encoding="UTF-8">`toric/compute_rows` := proc(H::array, S::array, edata::list, init_v,\134
</Font>        delta::vector, lifD::integer, trace::integer)
local guide,
        den_guide,        # guide of pts indexing denominator matrix
        cols,                # set of all monoms even appeared as col
        greedyalgo,        # F iff std algo w/known pts, T iff greedy algo finds pts
      i, ii, imax, ipoly, jmax, overts, todo, vt1, vt2, counter, vt;

    if type(init_v,matrix) then
        greedyalgo := true;
        todo := {eval(init_v)};
            cols := {eval(init_v)};
    else
        greedyalgo := false;
        todo := {op( map(i-&gt;matrix(lifD-1,1,i),init_v) )};
        cols := NULL;                         # safety
    fi;

    counter := 0;
    guide := {};                        # init set of rows
    den_guide := [];
    # printf(&quot;Constructing matrix rows:&quot;);

    while not (todo = {}) do                # continue while vt is defined

      vt := op(1, todo);
      todo := todo minus {eval(vt)};
      if true then
            counter := counter+1;
            # print(`compute rows: Row monomial`, counter, `equals`, vt);
      fi;
<Font encoding="UTF-8">      # if modp(counter,10)=0 then printf(&quot;%d.\134n&quot;,counter) fi;
</Font>
      overts := `toric/opt_verts`(edata, matadd(vt,delta,1,-1), lifD);

      # find largest index of input polytope contributing a vertex to optimal sum
      imax := lifD;

      while imax&gt;0 and overts[imax]=0 do imax:=imax-1 od;

      if imax=0 then
              if greedyalgo then ERROR(`imax=0`) else next fi;
      fi;

      # for vt1 in overts do if
          # vt1[1] &gt; imax then imax := vt1[1]; jmax := vt1[2] fi od;
      jmax := overts[imax];

      guide := guide union {[eval(vt),imax,jmax]};

<Font encoding="UTF-8">      printf(&quot;NUMER: %d,%d,%d: RC= %d,%d; overts %a\134n&quot;,\134
</Font>                vt[1,1],vt[2,1],vt[3,1],imax,jmax,eval(overts));

      if RATIONAL_FORMULA=1 then
          ii := imax-1;                 # search past (ie. below) imax
          while ii&gt;0 and overts[ii]=0 do ii:=ii-1 od;
          if ii&gt;0 then                  # unmixed: there's 2nd overts[ii]&gt;0
            den_guide := [ op(den_guide), [eval(vt),imax,jmax] ];
<Font encoding="UTF-8"> printf(&quot;denom: %d,%d,%d: RC= %d,%d; 2nd vtx summand = %d,%d (indices&gt;0)&quot;,\134
</Font>                vt[1,1],vt[2,1],vt[3,1],imax,jmax,ii,overts[ii]);
<Font encoding="UTF-8">            printf(&quot; and overts %a\134n&quot;,eval(overts));
</Font>          fi;
      fi; #RATIONAL_FORMULA

      if greedyalgo then
          vt2 := matadd(vt, col(H[imax], jmax), 1, -1);
          ipoly := S[imax];
          for i from 1 to coldim(ipoly) do        # find exponents occurring as..
            vt1 := matadd(vt2, col(ipoly, i));        # ..multiples of monomials in S[imax]
            if not `toric/vmem`(vt1, cols) then        
                cols := cols union {eval(vt1)};
                todo := todo union {eval(vt1)};
            fi
          od;
      fi;#greedy
    od;        # while

    RETURN( sort(convert(guide, list), `toric/guide_order`),
                sort (den_guide, `toric/guide_order`));
end: # `toric/compute_rows`

# Same as `toric/compute_rows` for dimension = #vars = 2 so lifD = #pols = 3.
# H          = c.hulls: arrays of arrays ((lifD-1) X num vertices) of input vertices
# S      = supports: arrays of arrays of input vertices plus interior points
# edata  = equations defining lower hull suitable for simplex package
# init_v = integer point in the Minkowski sum of the inputs H[i], 2 x 1 matrix
#           or list of all points
# delta  = random small displacement vector
# trace  = debug/message level during execution; 0 for silence.
#
# Returns sorted list &quot;guide&quot; indexing the matrix rows as polyn*monom products.
# Each row coded as list [ pt in Mink.sum, polynomial indx, monom in its support ]
#        so that the support pt (or monom) w/max polyn.index appears
#        in the optimal sum expressing the Mink.sum point.
#
# row_guide, todo, allcols: include column monoms ie. in Mink.sum.
# Invariant: allcols = row_guide union todo; row_guide, todo distinct.
# Add to `todo` if `allcols` unassigned (cheap test), then assign.
# Hence can use lists and check allcols for adding, instead of set union.
#
<Font encoding="UTF-8">`toric/comp_rows_2` := proc(H::array, S::array, edata::list, init_v,\134
</Font>                                delta::vector, trace::integer)
local        allcols,                        # array of column monoms
        row_guide,                        # matrix rows
        maxcoor,                        # max coor in Mink.sum of lifD polytopes
        i, coor,                         # indices
        lifD, vt,                        # #pols=#vars+1
        imax, ipoly, jmax, overts,
        todo,                                # (column) monoms to be examined
        den_guide, ii,                        # denominator matrix
        vt1, vt2, monoms, counter;
global  RATIONAL_FORMULA; 

    if not type(init_v,matrix) then ERROR(`list of Mink.sum points not implemented`) fi;

    lifD := 3;
    counter := 0;                        # only if trace&gt;1

    row_guide := [];                        # init rows
    den_guide := [];
    todo := { eval(init_v) };

    maxcoor := vector(lifD-1);
    for coor from 1 to lifD-1 do        # init
        maxcoor[coor] := max(op(convert(row(H[1],coor),list)));
    od;
    for i from 2 to lifD do for coor from 1 to lifD-1 do
        maxcoor[coor] := maxcoor[coor] + max(op(convert(row(H[i],coor),list)));
    od; od;
    if trace&gt;0 then lprint(`  maximum coordinates`,eval(maxcoor)); fi;
        
    allcols := array(0..maxcoor[1],0..maxcoor[2]);        # not assigned
    allcols[init_v[1,1],init_v[2,1]] := 1;                # assigned
    # printf(&quot;Constructing matrix rows:&quot;);

    while todo &lt;&gt; {} do                         # loop while vt defined
        vt := op(1, todo);
        todo := todo minus {eval(vt)};

        counter := counter+1;
        # if modp(counter,10)=0 then printf(&quot;call.opt_verts.%d &quot;,counter); fi;
        overts := `toric/opt_verts`(edata, matadd(vt,delta,1,-1), 3);        # lower hull vertex
        if trace&gt;0 then 
          print(`toric/comp_rows_2: Row monomial`,counter,`equals`,vt,`expressed`,overts);
        fi;

         # find max index `imax` of polytope contributing vertex to optimal sum
        imax := 3;
        while overts[imax]=0 do imax:=imax-1; if imax=0 then ERROR(`0-imax`) fi od;
        jmax := overts[imax];
        row_guide := [ op(row_guide), [eval(vt),imax,jmax] ];

        if trace&gt;1 then
          lprint(`values of imax,vt,overts equal`,imax,eval(vt),eval(overts));
        fi;

        if RATIONAL_FORMULA=1 then
          ii := imax-1;                 # search past (ie. below) imax
          while ii&gt;0 and overts[ii]=0 do ii:=ii-1 od; 
<Font encoding="UTF-8">          # printf(&quot;RatForm: ii=%d\134n&quot;,ii);
</Font>          if ii&gt;0 then                  # unmixed: there's 2nd overts[ii]&gt;0
            den_guide := [ op(den_guide), [eval(vt),imax,jmax] ];
<Font encoding="UTF-8">            printf(&quot;RatForm:unmixed %dth pt = %d,%d w/RC = %d,%d and 2nd vtx summand = %d,%d\134
                (indices &gt;0)\134n&quot;,nops(den_guide),vt[1,1],vt[2,1],imax,jmax,ii,overts[ii]);
</Font>            # print(`and overts`,overts);
          fi;
<Font encoding="UTF-8">          # printf(&quot;eXiting RATIONAL_FORMULA\134n&quot;);
</Font>        fi; # if RATIONAL_FORMULA

<Font encoding="UTF-8">        # printf(&quot;setting vt2=vt-col(%a[%d],%d), using S.\134n\134n&quot;,eval(H),imax,jmax);
</Font>        vt2 := matadd(vt, col(H[imax], jmax), 1, -1);
        ipoly := S[imax];
        monoms := coldim(ipoly);

        for i from 1 to monoms do                # find exponents occurring as..
            vt1 := matadd(vt2, col(ipoly, i));        # ..multiples of monomials in S[imax]
            if not assigned( allcols[vt1[1,1],vt1[2,1]] ) then        
                allcols[vt1[1,1],vt1[2,1]] := 1;
                todo := todo union {eval(vt1)};
            fi;
        od;
    od;
    
    RETURN( sort (row_guide, `toric/guide_order`), sort (den_guide, `toric/guide_order`));

end: # `toric/comp_rows_2`

# criterion for sorting &quot;guide&quot; list of matrix rows
#
`toric/guide_order` := proc(a, b) `toric/v_order`(op(1, a), op(1, b)) end:

# true iff a&lt;b lexicographically
#
`toric/v_order` := proc(a::matrix, b::matrix)
  local bigger, d, i;
    d := rowdim(a);
    bigger := false;
    for i to d do
       if a[i,1] &lt; b[i,1] then
           bigger := true;
           break;
       elif a[i,1] &gt; b[i,1] then
           bigger := false;
           break;
       fi;
    od;
    bigger;
end:                # `toric/v_order`

# Input:
#   suppMat[d-1,#monoms] = matrix of support points
#   hullSet = set of indices in suppMat defining c.hull
#   Optional: list of lift values, one per supp.point
# sort columns of suppMat on `toric/v_order`, affecting suppMat
# Return:
#   hull2supp[h]=s indexing: hull-col h = supp-col s
#   submatrix of suppMat comprised of hull vertices
#     must be in same order as supportMatrices to detect diag.monoms
#   If 3rd arg: return list of sorted lift values
#
`toric/sort_inplace` := proc(hullSet::set,suppMat::matrix)
#                                                        liftvals
  local rows, cols, i, j, k, d, n, noflips, temp,
        isVertex, hull2supp, liftvals;

  # print('input_hullset,suppmat',hullSet,suppMat);
  d := rowdim(suppMat);
  n := coldim(suppMat);
  isVertex := vector(n,0);                        # init
  for i in hullSet do isVertex[i] := 1 od;
  if nargs&gt;2 then
    if nops(args[3])&lt;&gt;n then ERROR(`bad 3rd arg`) fi;
    liftvals:= vector(args[3]);
  fi;

  for i from n-1 by -1 to 1 do
    noflips := true;
    for j from 1 to i do
      if `toric/v_order`(submatrix(suppMat,1..d,[j+1]), submatrix(suppMat,1..d,[j])) then
        noflips := false;
        if isVertex[j] &lt;&gt; isVertex[j+1] then
          temp:=isVertex[j]; isVertex[j]:=isVertex[j+1]; isVertex[j+1]:=temp;
        fi;
        for k from 1 to d do
          temp := suppMat[k, j+1];
          suppMat[k, j+1] := suppMat[k, j];
          suppMat[k, j] := temp;
        od;#k
        if nargs&gt;2 then
          temp:=liftvals[j+1];liftvals[j+1]:=liftvals[j]:liftvals[j]:=temp;
        fi;
      fi;#v_order
    od;#j
    if noflips then break fi;
  od;
  # lprint(`This is a sorted support`, eval(suppMat));

  hull2supp := vector(nops(hullSet),0);                # init
  j:=1;
  for i from 1 to n do
    if isVertex[i]=1 then
      hull2supp[j] := i;                        # j-th hull col = i-th supp col
      j := j+1;
    fi;
  od;

  # print('ret hull2set',hullSet); print(convert(liftvals,list));
  if nargs&gt;2 then
<Font encoding="UTF-8">    [eval(hull2supp), evalm(submatrix(suppMat,1..d,convert(hull2supp,list))),\134
</Font>        convert(liftvals,list)];
  else
    [eval(hull2supp), evalm(submatrix(suppMat,1..d,convert(hull2supp,list)))];
  fi;

end:        # `toric/sort_inplace`
# ----------------------------------------------------------------------
addtohelp(`toric/mixed`):
# ----------------------------------------------------------------------
## HELP `toric/mixed`
##
## `toric/mixed` - sparse (toric) resultant matrix of supports
##
## CALLING SEQUENCE:
##     `toric/mixed`(hulls, supps, allpoints);
##     `toric/mixed`(hulls, supps, allpoints, delta);
##     `toric/mixed`(hulls, supps, allpoints, delta, lifting);
##
## PARAMETERS:
##     hulls - array of sets defining Newton polytopes
##     supps - 3-dimensional array exrepssing supports
##     allpoints - list of int.points in Mink.sum; ignore if integer
##     delta - vector or list of real numbers
##     lifting - 2-dimensional array or matrix of lifting
## DESCRIPTION:
## - Compute the sparse (toric) resultant matrix of the system defined by
##   the given supports, containing indeterminate coefficients.
##   Coefficients are labeled with respect to the sorted supports.
##   The number of rows in the coefficients of the first polynomial
##   is optimal.
##   
## - Letting n be the number of variables, n+1=lifD must be the number
##   of polynomials.  Then supps must be an array of n+1 arrays of
##   size n x m, where m = the number of points in that support.
##   
## - New argument allpoints is list of all integer points in the Minkowski
##   sum of Newton polytopes; can be integer (for backward compatibility),
##   in which case it is ignored.
## 
## - If delta is given, it is used as the geometric perturbation
##   applied to the Minkowski sum of the Newton polytopes.
##   The n entries must be sufficiently small in order not to perturb
##   points in the sum outside adjacent cells in the sum's subdivision.
##   If delta is not given, it is chosen randomly.
##
## - If lifting is given, it specifies the affine lifting functions
##   of the Newton polytopes, thus defining the mixed subdivision of
##   their Minkowski sum which will specify the matrix.
##   It must be a square matrix of dimension n+1, each row corresponding
##   to a Newton polytope.  If lifting is not given, it is chosen randomly.
##
## - The function returns a sequence of 4 objects.  The first is a list
##   of two matrices: the resultant matrix and the denominator matrix,
##   if RATIONAL_FORMULA=1, otherwise an empty matrix.  The second one
##   is a list of the rows with information about how each was obtained:
##   the corrresponding Minkowski sum point, the chosen polynomial and
##   its monomial in the row content function of the point.  Third is the
##   array of the sorted supports, and last is an array of the monomials
##   appearing on the matrix diagonal.
##
## - The function is based on an implementation by Canny and Pedersen.
##   The algorithm is the greedy version, by Canny and Pedersen 
##   (Tech. Report 1394, C.S. Dept, Cornell University, 1993),
##   of the algorithm by Canny and Emiris (Proc. AAECC-1993, pp. 89.  
##   Final version J. ACM, 47:417-451, 2000).  See these references
##   for a definition of the row content function.
## 
## EXAMPLES:
<Font encoding="UTF-8">##&gt; supp_hull := `toric/polytope`([x^2-x+y*x-1,x*y-3,2*x-x*y-1],[x,y]):\134
</Font>##&gt; `toric/mixed`(supp_hull[1], supp_hull[2], 0);
##
## toric/mixed(): Random Delta = .061 .058
## Random affine lifting = array(1..3,1..3,[(2,3)=784,(1,1)=351,(1,2)=234,
##   (3,2)=599,(3,1)=117,(2,2)=34,(2,1)=898,(3,3)=909,(1,3)=707])
## [[c2x1     0      c2x2     0       0  ]   ]
## [[                                    ]   ]
## [[c3x1    c3x2    c3x3     0       0  ]   ]
## [[                                    ]   ]
## [[c1x1    c1x2    c1x3    c1x4     0  ],[]],
## [[                                    ]   ]
## [[ 0      c3x1     0      c3x2    c3x3]   ]
## [[                                    ]   ]
## [[ 0      c2x1     0       0      c2x2]   ]
##
##     [2]          [3]          [3]          [4]          [4]
##   [[[ ], 2, 1], [[ ], 3, 2], [[ ], 1, 2], [[ ], 3, 2], [[ ], 2, 2]],
##     [1]          [1]          [2]          [1]          [2]
##
##   [[0    1    1    2]  [0    1]  [0    1    1]]
##   [[                ], [      ], [           ]], [{3}, {1, 2}, {2}]
##   [[0    0    1    0]  [0    1]  [0    0    1]]
##
## SEE ALSO:
## spresultant, `toric/polytope`
##
`toric/mixed` := proc(hulls::array, supps::array, allpoints )
#                                                           , delta , lifting
local        lifD,                                # number of polytopes = dimension + 1
        delta,                                # pertubration vector
        hullArr,                        # hullArr[p]=[d-1,#hull.verts] 
        hull2supp,                        # hull2supp[i]=vector of #hull monoms
        edata, i, ip, ipoly, ivert, j, k, zeroes,
        msize,                                # sparse resultant (Newton) matrix M size
        mons,                                # number of monoms in one polynomial
        vt1, vt2,
        alift,                                # lifting: input OR affine ie. random dxd matrix
        rowsperpol,                        # number of matrix M rows per polynomial
        guide_rows, M,                        # outputs: row coding, resultant matrix
        denom_rows, den_ix,             # denominator rows, indices
        diagMons,                        # array of sets w/diag.monoms per poly
        total_time, rows_time, constr_time,
        outList;
global  tot_time_lp, RATIONAL_FORMULA;

    total_time := time();                        # init
    lifD := op(op(2,eval(hulls)))[2];                # #polytopes = dimension + 1
    # lifD := rowdim(convert(hulls,matrix));
    if RATIONAL_FORMULA=1 and lifD&gt; 9 then
        RATIONAL_FORMULA := 0;
<Font encoding="UTF-8">        printf(&quot;NO RATIONAL FORMULA POSSIBLE FOR &gt; 9 POLYNOMIALS due to complexity\134n&quot;);
</Font>    fi;
<Font encoding="UTF-8">    if RATIONAL_FORMULA=1 then printf(&quot;computing RATIONAL formula\134n&quot;);
        else printf(&quot;computing numerator ONLY\134n&quot;); fi;
</Font>
    delta := `toric/randvect` (lifD-1);                         # fix type (array)
    if nargs&gt;3 then
        for i to lifD-1 do delta[i] := args[4][i]; od;
            printf(&quot;toric/mixed(): Given Delta =&quot;);         # optional arg
    else printf(&quot;toric/mixed(): Random Delta =&quot;);        # random displacement
    fi;
    for i from 1 to lifD-1 do printf(&quot; %.6f&quot;,delta[i]); od;
<Font encoding="UTF-8">    printf(&quot;\134n&quot;);
</Font>
    if nargs&gt;4 then
        alift := args[5];
<Font encoding="UTF-8">        printf(&quot;Given lifting:\134n&quot;);
</Font>        # print(eval(alift));
    else
            alift := `toric/randaff`(lifD);                # random affine functional as matrix dxd
<Font encoding="UTF-8">        printf(&quot;Random affine lifting =%a.\134n&quot;,eval(alift));
</Font>    fi;

    tot_time_lp := 0;                                # initialize global timer
<Font encoding="UTF-8">    # printf(&quot;toric/mixed(): sorting support points\134n&quot;);
</Font>
    hullArr := array(1..lifD);                        # explicit subsets of supp
    if type(alift,matrix) then
      for i from 1 to lifD do
        outList := `toric/sort_inplace` (hulls[i],supps[i]);
        hull2supp[i] := outList[1];                # hull2supp[hull.col]=supp.col
        hullArr[i] := outList[2];                # submatrix of new supps[i]
         print('hull_to_supp@hull_arr',eval(hull2supp[i]),eval(hullArr[i]));
      od;
    else                                        # else alift=[list-per-supp]
      edata := NULL;                                # temp.seq of sorted lists
      k := 0;
      for i from 1 to lifD do
        outList := `toric/sort_inplace`
                (hulls[i],supps[i], [ seq(alift[i],i=(k+1)..(k+coldim(supps[i]))) ] );
        hull2supp[i] := outList[1];
        hullArr[i] := outList[2];
        edata := edata, outList[3];                # list of sorted lifts of supp.
      od;
      alift := [edata];
      printf(&quot;Sorted liftings,supps =%a&quot;,eval(alift)); print(hullArr);
    fi;

    if false then
      lprint(`The coeff labels correspond to the sorted supports:`);
      if lifD=2 then print(eval(supps[1]),eval(supps[2]));
        elif lifD=3 then print(eval(supps[1]),eval(supps[2]),eval(supps[3]));
        else for i from 1 to lifD do lprint(eval(supps[i])); od;
      fi;
<Font encoding="UTF-8">      printf(&quot;toric/mixed(): computing data common to all vertex equations\134n&quot;);
</Font>    fi;

    edata:= `toric/make_eqns`(hullArr,alift,lifD);  # =[obj,conveq,lhs,#verts] 

    if type(allpoints,integer) then
      vt1 := `toric/start_vertex` (hullArr,lifD,edata,delta);
<Font encoding="UTF-8">      printf(&quot;Passing start vertex=%a.\134n&quot;,eval(vt1));
</Font>    else
      if not type(allpoints,list) then ERROR(`bad type of allpoints`) fi;
      vt1 := allpoints;
<Font encoding="UTF-8">      printf(&quot;Passing %d allpoints instead of start vertex.\134n&quot;,nops(allpoints));
</Font>    fi;

<Font encoding="UTF-8">     printf(&quot;greedy search for row indices\134n&quot;);
</Font>    rows_time := time();
    if lifD=3 then
<Font encoding="UTF-8">        # printf(&quot;computing rows by special 2-dim routine\134n&quot;);
</Font>        print(eval(hullArr), supps, edata, delta);
        outList := `toric/comp_rows_2` (hullArr, supps, edata, vt1, delta,2);
        guide_rows := outList[1];
        denom_rows := outList[2];
    else
<Font encoding="UTF-8">        # printf(&quot;computing rows by general-dim routine\134n&quot;);
</Font>        outList := `toric/compute_rows` (hullArr, supps, edata, vt1, delta, lifD, 2);
        guide_rows := outList[1];
        denom_rows := outList[2];
    fi;
    rows_time := time() - rows_time;

    # printf(&quot;toric/mixed(): got guide_rows=&quot;); lprint(guide_rows);

    constr_time := time();
    msize := nops(guide_rows);
<Font encoding="UTF-8">    printf(&quot;toric/mixed(): constructing %d-dim matrix\134n&quot;,msize);
</Font>   # print(eval(guide_rows));
    M := array(1..msize, 1..msize);
    rowsperpol := vector(lifD,0); 

    # diagonal monomials

    diagMons := array(1..lifD);
    for i from 1 to lifD do diagMons[i] := {}; od;
    vt1 := 0;                        # reset

    for i from 1 to msize do
      ivert := guide_rows[i];        # one row as list of 3 elts:
                                      # [Mink.sum pt, poly.indx, monom in hullArr]

      ip := ivert[2];                # 1 &lt;= ip &lt;= numpolys=d
      rowsperpol[ip] := rowsperpol[ip] + 1;
      vt1 := matadd(ivert[1], col(hullArr[ip], ivert[3]), 1, -1);
      ipoly := supps[ip];
      mons := coldim(ipoly);

      j := 1;
      for k from 1 to mons do
            vt2 := matadd(col(ipoly,k), vt1);        # vt2 = col monom
            while not equal(eval(vt2), guide_rows[j][1]) do
                      if j&gt;msize then ERROR(`cant find monom vt2`) fi;
                M[i, j] := 0;
                j := j + 1;
            od;
            M[i, j] := cat(`c`,ip,`x`,k);
            j := j + 1;
      od;        # k-th monomial
      # print(`ivert=`,ivert,`vt1=`,vt1,`ipoly=`,ipoly,`mons=`,mons);

      zeroes := j;                                # rest of row is zero
      for j from zeroes to msize do M[i, j] := 0; od;

      # to deal w/degeneracy: indices of monomials on diagonal
      # ivert[3] indexes in hullArr, only supps passed on w/diagMons
      diagMons[ip] := diagMons[ip] union { hull2supp[ip][ivert[3]] };
<Font encoding="UTF-8">      # print(i,`-th row done:`,eval(ivert[1]), eval(col(hullArr[ip],ivert[3])),eval(vt1),\134
</Font>      #           ivert[3],eval(hull2supp[ip][ivert[3]]),`diagMons=`,diagMons);

    od;                # i-th row

    den_ix := NULL;
    if RATIONAL_FORMULA=1 then
        # print(&quot;constructing denominator, with:&quot;,denom_rows,guide_rows);
        k := 1;
        for i to msize do
          if (k &lt;= nops(denom_rows)) and equal( denom_rows[k][1], guide_rows[i][1]) then
            den_ix := eval(den_ix), i;
            k := k + 1;
          fi;
        od; #i
        if k &lt;&gt; nops(denom_rows)+1 then ERROR(`error in counting denom`) fi;
    fi;#RATIONAL_FORMULA

    constr_time := time() - constr_time; 
<Font encoding="UTF-8">    # printf(&quot;toric/mixed: Delta = %a\134n&quot;, eval(delta));
    printf(&quot;Subdivision resultant matrix of size %d x %d.\134n&quot;,rowdim(M),coldim(M));
    if rowdim(M)=1 then printf(&quot;SPARSE RESULTANT MAY BE POWER OF MATRIX DETERMINANT\134n&quot;) fi;
    # printf(&quot;Number of rows per polynomial=%a\134n&quot;,eval(rowsperpol));
    # printf(&quot;Monomials on the diagonal are:\134n&quot;,eval(diagMons));
</Font>    if RATIONAL_FORMULA=1 then
<Font encoding="UTF-8">        printf(&quot;denominator matrix of dim %d.\134n&quot;,nops(denom_rows));
</Font>    fi;

    if true then
      total_time := time() - total_time;
<Font encoding="UTF-8">      printf(&quot;timings[secs] and percents:\134n&quot;);
</Font>      printf(&quot;optimize=%as (%2.0f%%), find rows=%as (%2.0f%%),&quot;,
        tot_time_lp,100*tot_time_lp/total_time,rows_time,100*rows_time/total_time);
<Font encoding="UTF-8">      printf(&quot;construct=%as (%2.0f%%), total=%as\134n&quot;,
</Font>        constr_time,100*constr_time/total_time,total_time);
    fi;

<Font encoding="UTF-8">    printf(&quot;mixed returning [numM,denM],[pts,RC],supps,diagMons,denom_rows\134n&quot;);
    RETURN ([ evalm(M), submatrix(M,[den_ix],[den_ix])],eval(guide_rows),eval(supps),\134
</Font>        eval(diagMons),eval(denom_rows) );
end: # toric/mixed

#----------------------------------------------------------------------
addtohelp(`toric/matspec`):
#---------------------------------------------------------------------- 
## HELP `toric/matspec`
##
## `toric/matspec` - specialize (numerator and denominator) matrices
##
## CALLING SEQUENCE:
##     `toric/matspec`(inlist, polyns, elvars, Int_Coefs)
##
## PARAMETERS:
##     inlist - list of data from spresultant
##     polyns - list of input polynomials
##     elvars - list of eliminated variables
##     Int_Coefs - boolean (default)
##
## DESCRIPTION:
## - De-assemble &quot;inlist&quot; and get coefficients, apply perturbation if
##   necessary to diagonal elements.
##
## - Items of &quot;inlist&quot;: 1st item is list of 2 matrices with generic
##   coefficients. 2nd is monomials indexing numerator-matrix columns.
##   3rd is array of support matrices. If PERT_DEGEN_COEFS, 4th item
##   contains diagonal entries.
##
## - The function returns a list of 2 specialized matrices: numerator
##   and denominator.
##
## SEE ALSO:
## spresultant
##
##
`toric/matspec` := proc (inList::list, polyns::list, elvars::list, Int_Coefs::boolean)
  local symbMat, specMat, suppArr, colMons, diagMon, elvarsArr,
        specSet, coefval, pertCoef, i, j, flag, mm, numvar;
  global RATIONAL_FORMULA, PERT_DEGEN_COEFS;

  numvar := nops(elvars);
  symbMat := eval(inList[1]);                # array/list
  if RATIONAL_FORMULA=1 and not type(symbMat[2],matrix) then
        ERROR(`no denominator computed`)
  fi; 
  colMons := map(el-&gt;el[1],inList[2]);
<Font encoding="UTF-8">  # printf(&quot;monomials indexing matrix columns %a:\134n&quot;,colMons);
</Font>
  suppArr := eval(inList[3]);                # sorted supports used for cixj in symbMat
  if PERT_DEGEN_COEFS&gt;0 then 
    diagMon := eval(inList[4]);                # array(1..d) of sets
  fi;

  elvarsArr := array(1..numvar,elvars);
  specSet := {};

  # treat special/degenerate coefficients by adding t-system

  if PERT_DEGEN_COEFS&gt;0 then
    pertCoef := array(1..(numvar+1));
    # lprint(`spresultant() fills`,eval(pertCoef),`from`,eval(diagMon)); 
    for i from 1 to (numvar+1) do
      pertCoef[i] := vector(coldim(suppArr[i]),0);        # some pertCoef=0
      flag := false;                                        # exists pertCoef=1
      for j in diagMon[i] do                                # index into support
        if not flag then pertCoef[i][j] := 1; flag := true;
        else
          pertCoef[i][j] := RandSign()*rand(1..(10^ceil(evalf(log[2](numvar)))))();
           if not type(pertCoef[i][j],numeric) then ERROR(`no numeric pert.coeff`) fi;
        fi;
      od;
    od;        #for i
  fi;

  # i=1 must be u-polynomial in u-resultant
  for j from 1 to coldim(suppArr[1]) do
    coefval := `toric/coefofexp`(polyns[1],elvarsArr,col(suppArr[1],j));
    if Int_Coefs then coefval := `toric/map_coefs`(round,coefval); fi;
    if PERT_DEGEN_COEFS&gt;0 and type(PERT_DEGEN_COEFS,odd) then                
      coefval := coefval+t*pertCoef[1][j];         # overconstrained
    fi;
    specSet := eval(specSet) union {`c1x`||j = eval(coefval) }
  od;
  for i from 2 to (numvar+1) do for j from 1 to coldim(suppArr[i]) do
    coefval := `toric/coefofexp`(polyns[i],elvarsArr,col(suppArr[i],j));
    if Int_Coefs then coefval := `toric/map_coefs`(round,coefval); fi;
    if PERT_DEGEN_COEFS&gt;0 then coefval := coefval+t*pertCoef[i][j]; fi;
    specSet := eval(specSet) union {`c`||i||`x`||j = eval(coefval) }
  od; od;

<Font encoding="UTF-8">  # printf(&quot;using specialized coefficients:%a\134n&quot;,eval(specSet));
</Font>
  for mm from 1 to 1+RATIONAL_FORMULA do
    specMat[mm] := matrix (rowdim(symbMat[mm]),coldim(symbMat[mm]),0); 
    for i from 1 to rowdim(symbMat[mm]) do for j from 1 to coldim(symbMat[mm]) do
      if symbMat[mm][i,j]&lt;&gt;0 then
        specMat[mm][i,j] := subs (specSet, symbMat[mm][i,j]);
      fi;
    od; od;
  od; # matrix mm
  
  RETURN ([ evalm(specMat[1]), evalm(specMat[2]), eval(colMons) ]);
end:          # `toric/matspec`
PERT_DEGEN_COEFS := 0:
#----------------------------------------------------------------------
addtohelp(spresultant):
#----------------------------------------------------------------------
## HELP spresultant
##
## spresultant - Sparse (toric) resultant matrix of polynomials
##
## CALLING SEQUENCE:
##     spresultant(pols, vars);
##     spresultant(pols, vars, delta);
##     spresultant(pols, vars, delta, lifting);
##
## PARAMETERS:
##     pols - list of polynomials
##     vars - list of variables
##     delta - vector or list of real numbers
##     lifting - 2-dimensional array of lifting
## DESCRIPTION:
## - Compute the sparse (toric) resultant matrix of the given polynomials
##   by eliminating variables vars.  The number of rows in the
##   coefficients of the first polynomial is optimal (equal to the
##   respective degree of the sparse resultant).
##
## - Letting n be the number of variables, n+1 must be the number of
##   polynomials.
##
## - If delta is given, it is used as the geometric perturbation
##   applied to the Minkowski sum of the Newton polytopes.
##   It must contain n entries, sufficiently small in order not to perturb
##   points in the sum outside adjacent cells in the sum's subdivision.
##   If delta is not given, it is chosen randomly.
##
## - If lifting is given, it specifies the affine lifting functions
##   of the Newton polytopes, thus defining the mixed subdivision of
##   their Minkowski sum which will specify the matrix.
##   It must be a square matrix of dimension n+1, each row corresponding
##   to a Newton polytope.  If lifting is not given, it is chosen randomly.
##
## - The function returns a square matrix, whose determinant is a multiple
##   of the sparse resultant for generic coefficients.  For degenerate
##   coefficients, a perturbation can be defined by setting global variable
##   PERT_DEGEN_COEFS, as described by D'Andrea and Emiris (Computing Sparse
##   Projection Operators, In &quot;Symbolic Computation: Solving Equations in
##   Algebra, Geometry, and Engineering, AMS, 2001).  The 2nd returned item
##   is a list of the monomials indexing the columns.
##
## - The matrix construction implements the greedy version, by Canny and
##   Pedersen (Tech. Report 1394, C.S. Dept, Cornell University, 1993),
##   of the algorithm by Canny and Emiris (Proc. AAECC-1993.  Final version
##   J. ACM, 47:417-451, 2000).
##
## EXAMPLES:
##&gt; spresultant([x^2-x*z^2+y*x+z-1,x*y*z-3,2*x-x*y-z],[x,y]);
##
## toric/mixed(): Random Delta =  -.035 .044
## Random affine lifting = array(1..3,1..3, [(1,2)=882,(3,1)=537,(3,3)=209,(2,3)=82,
##   (2, 2)=582,(1, 1)=828,(3, 2)=374,(2, 1)=736,(1, 3)=176])
##   [-3   0   z  0  0]
##   [ 0  -3   0  0  z]
##   [-z   2  -1  0  0], [[1],[2],[2],[3],[3]]
##   [      2         ]   [1] [1] [2] [1] [2]
##   [z-1 -z   1  1  0]
##   [ 0  -1   0  2 -1]
##
##&gt; spresultant([x+3*y,2*x-y+5*x^2*y,u0+u1*x+u2*y],[x,y],
## [.028,.078],matrix([[15,149,392],[222,381,684],[35,350,57]]));
## toric/mixed(): Given Delta = .028 .078
##                   [ 15 149 392]
##  Given lifting =, [222 381 684]
##                   [ 35 350  57]
##   [ 3  0 1  0  0  0]
##   [ 0  3 0  1  0  0]
##   [-1  0 2  0  0  5], [[1],[1],[2],[2],[2],[3]]
##   [u0 u2 0 u1  0  0]   [2] [3] [1] [2] [3] [2]
##   [ 0  0 0  0  3  1]
##   [ 0  0 0 u0 u2 u1]
##
## SEE ALSO:
## `toric/mixed`
##
spresultant := proc (in_polyns::list, elvars::list )
#                                              , delta, lifting
  local outList, polyns, numvar, i, j, pol, req_args, INTEGER_COEFFS;
  global PERT_DEGEN_COEFS; 
 
  unassign('x');                 # strings to be used later
  unassign('lam');

  # 0: no pert, 1: overcons, random pert, 2: u-res/random pert
  if PERT_DEGEN_COEFS=1 then
<Font encoding="UTF-8">    printf(&quot;WILL PERTURB MATRIX BY RANDOM PERTURBATION OF OVERCONSTRAINED SYSTEM\134n&quot;);
</Font>  elif PERT_DEGEN_COEFS=2 then
<Font encoding="UTF-8">    printf(&quot;WILL PERTURB WELLCONSTRAINED SYSTEM, LEAVE 1st POLYNOMIAL AS IS\134n&quot;);
</Font>  fi;

  INTEGER_COEFFS := true;
  if INTEGER_COEFFS then polyns := map(`toric/scaled`,in_polyns);
  else polyns := in_polyns; fi;

  req_args := 2;
  if nargs&lt;req_args then ERROR(`small number of arguments to spresultant()`) fi;
  numvar := nops(elvars);
  if nops(polyns) &lt;&gt; (numvar+1) then ERROR(`bad #polynomials=`,nops(polyns)) fi;

  polyns := map(expand,polyns);
  for i from 1 to numvar+1 do for j from 1 to numvar do
    polyns[i] := simplify (polyns[i] * elvars[j]^(-ldegree(polyns[i],elvars[j])));
  od; od;

  # no output to file; outList=[suppArr, hullSet]
  # suppArr[p]=mat[dim,num], hullSet[p]=set of columns in suppArr[p]

  outList := `toric/polytope` (polyns, elvars, 0);
  print(outList);

  # 3rd arg=0: no info on int.points in Mink.sum
  # outList &lt;- seq: symb.matrix, row guide list, sorted supps, diag.monoms

  if nargs=req_args then
    outList := `toric/mixed` (eval(outList[1]), eval(outList[2]), 0);
  elif nargs=req_args+1 then
    outList := `toric/mixed` (eval(outList[1]), eval(outList[2]), 0, args[3]);
  elif nargs=req_args+2 then
    outList := `toric/mixed` (eval(outList[1]), eval(outList[2]), 0, args[3], args[4]);
  fi;

  outList := `toric/matspec` (eval([outList]), polyns, elvars, INTEGER_COEFFS);

  RETURN (outList);
end:          # spresultant

# inputs:
#   pointArr = dxn array point coords: d=dimension, n=#points
#   limit = iteration limit
# output
#   subset of pointArr column indices, expressing vertices
#
# Algorithm for (approximating) vertices of convex hull by
# sorting input points in random directions to find some vertices
#   but certain vertex may not be seen
#   in lo-dim hull, int.pt may be both min &amp; max: dont accept it
#   tie in certain direction may give boundary point but not vertex
# Canny-Pedersen used to obtain randomized superset of vertices
# Now used to obtain certified subset of vertices
# deterministically use LinProg to check remaining points
#
`toric/comp_hull` := proc(pointArr::matrix, limit::integer)

  local        dim, i, j,
        mx, maxindex, maxtie, mn, minindex, mintie,
        num, rv,
              vertset, unprocessed, interior,
        vertlhs, conveq, convsum, lambda, sub, temp;

    dim := rowdim(pointArr);                # dim = dimension
    num := coldim(pointArr);                # num = numbers of points

    # randomized computation of subset of verts if hull full dimensional

    vertset := {};
    unassign('i');
    unprocessed := {i$i=1..num};

    for i from 1 to limit do
        rv := randmatrix(1,dim);
        rv := scalarmul(rv, 1/ `toric/twonorm`(rv));
        # lprint(`randvector`,eval(rv));

        minindex := 1;
        maxindex := 1;
        mn := multiply(rv, col(pointArr, 1));
        mn := mn[1];
        mx := eval(mn);
        mintie := false; maxtie := false;

        for j from 2 to num do
            temp := multiply(rv, col(pointArr, j));
            temp := temp[1];
            if temp &lt; mn then
                minindex := j;
                mn := temp;
                mintie := false;
            elif temp &gt; mx then
                maxindex := j;
                mx := temp;
                maxtie := false;
            else
                if temp=mn then mintie := true; fi;
                     if temp=mx then maxtie := true; fi;
            fi;
        od; #j

        # mn=mx iff degenerate hull, then dont decide
        # mintie or maxtie may have extreme pt, not vertex: dont decide
        if minindex&lt;&gt;maxindex then
          if not mintie then
            vertset := vertset union {minindex};
            unprocessed := unprocessed minus {minindex};
              # lprint(`vertex w/min inn.prod`,minindex,eval(mn));
          fi;
          if not maxtie then
            vertset := vertset union {maxindex};
            unprocessed := unprocessed minus {maxindex};
              # lprint(`vertex w/max inn.prod`,maxindex,eval(mx));
          fi;
        fi;

    od; #i: ends `limit` random iterations

    # lprint (`undecided`,unprocessed); 

    # Now use LP to check other vertices

    lambda := matrix(1, num);                         # new variables
    for i from 1 to num do lambda[1,i] := cat(`lam`,i) od;
    interior := {};
    unassign('j');
    temp := { j$j=1..num };                        # check pt against hull(temp)
    
    # lprint (`subset of verts`,vertset);
    # lprint(`check undecided:`,eval(unprocessed),`by LP using:`,eval(temp));

    # while (work minus work1 &lt;&gt; {}) or (work1 minus work &lt;&gt; {}) do work:=work1;

    for i in unprocessed do
                temp := temp minus {i};
            sub := convert(temp,list);                # superset of vertices
            convsum := 0;
            for j in temp do
              convsum := convsum + lambda[1,j]
            od;
            conveq := {convsum = 1};                         # convexity
            vertlhs := multiply(submatrix(pointArr, 1..dim, sub),
                                transpose(submatrix(lambda, [1], sub)));
            for j from 1 to dim do
                conveq := conveq union {vertlhs[j, 1] = pointArr[j, i]}
            od;
            # lprint (`running LP on`,col(pointArr,i));
            if feasible(conveq, NONNEGATIVE) then 
                # lprint (`LP:interior point`,col(pointArr,i));
                interior := interior union {i};
                if member(i,vertset) then
                  ERROR(`interior pt in vtx subset`)
                fi;
            else
                vertset := vertset union {i};
                        temp := temp union {i};
            fi;
    od; #i

    eval(vertset);
    # submatrix(pointArr, 1..dim, convert(vertset, list));

end: # `toric/comp_hull`</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVExUkFUSU9OQUxfRk9STVVMQUYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIzo9RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtSSNtbkdGJDYkUSIwRidGOS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRidGOQ==">IiIh</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L3" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart;</Text-field>
</Input>
</Group>
<Group labelreference="L4" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="2D Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="f1 := -2*z1*u[i]+u[i]^2+u[i+1];" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzZVLUkjbWlHRiQ2JVEjZjFGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUkjbW9HRiQ2LVEqJmNvbG9uZXE7RidGMi8lJmZlbmNlR0YxLyUqc2VwYXJhdG9yR0YxLyUpc3RyZXRjaHlHRjEvJSpzeW1tZXRyaWNHRjEvJShsYXJnZW9wR0YxLyUubW92YWJsZWxpbWl0c0dGMS8lJ2FjY2VudEdGMS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkktRjY2LVEqJnVtaW51czA7RidGMkY5RjtGPUY/RkFGQ0ZFL0ZIUSwwLjIyMjIyMjJlbUYnL0ZLRlAtSSNtbkdGJDYkUSIyRidGMi1GNjYtUSJ+RidGMkY5RjtGPUY/RkFGQ0ZFL0ZIUSYwLjBlbUYnL0ZLRlotRiw2JVEjejFGJ0YvRjJGVi1GLDYlUSJ1RidGL0YyLUkobWZlbmNlZEdGJDYmLUYjNiYtRiw2JVEiaUYnRi9GMi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJStleGVjdXRhYmxlR0YxRjJGMi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1GNjYtUSIrRidGMkY5RjtGPUY/RkFGQ0ZFRk9GUUZpbi1JJW1zdXBHRiQ2JUZcby1GIzYlRlIvRjBRJXRydWVGJy9GM1EnaXRhbGljRicvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnRl9wRmluLUZdbzYmLUYjNihGYW9GX3AtRlM2JFEiMUYnRjJGZG9GZ29GMkYyRmlvRlxwLUY2Ni1RIjtGJ0YyRjkvRjxGaHBGPUY/RkFGQ0ZFRllGSkZWLUYsNiVRI2YyRidGL0YyRjVGTEZSRlYtRiw2JVEjejJGJ0YvRjJGVkZpbkZecUZfcEZpbi1GY3A2JUZecUZlcEZbcUZfcEZpbi1GXW82Ji1GIzYoRmFvRl9wRlJGZG9GZ29GMkYyRmlvRlxwRmVxRlZGVi1GLDYlUSNmM0YnRi9GMkY1RkxGaW5GYnAtRjY2LVEoJm1pbnVzO0YnRjJGOUY7Rj1GP0ZBRkNGRUZPRlEtRmNwNiUtRiw2JUZobkZncEZpcEZlcEZbcUZfcC1GLDYlRl5yRmdwRmlwRmVxLUknbXNwYWNlR0YkNiYvJSdoZWlnaHRHUSYwLjBleEYnLyUmd2lkdGhHRlovJSZkZXB0aEdGZnMvJSpsaW5lYnJlYWtHUShuZXdsaW5lRictRmJzNiZGZHNGZ3NGaXMvRlx0USVhdXRvRictRiw2JVEhRidGZ3BGaXBGZG9GZ29GMg==">Qyg+SSNmMUc2IiwoKiZJI3oxR0YlIiIiJkkidUdGJTYjSSJpR0YlRikhIiMqJEYqIiIjRikmRis2IywmRi1GKUYpRilGKUYpPkkjZjJHRiUsKComSSN6MkdGJUYpRjFGKUYuKiRGMUYwRikmRis2IywmRi1GKUYwRilGKUYpPkkjZjNHRiUsKCokRihGMCEiIkYvRkFGOEYpRik=</Equation></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVEjZjFGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSM6PUYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUYjNiktRjY2LVEqJnVtaW51czA7RidGOUY7Rj5GQEZCRkRGRkZIL0ZLUSwwLjIyMjIyMjJlbUYnL0ZORlUtRiM2KC1JI21uR0YkNiRRIjJGJ0Y5LUY2Ni1RMSZJbnZpc2libGVUaW1lcztGJ0Y5RjtGPkZARkJGREZGRkgvRktRJjAuMGVtRicvRk5GW28tRiw2JVEjejFGJ0YvRjJGZ24tSSVtc3ViR0YkNiUtRiw2JVEidUYnRi9GMi1GIzYlLUYsNiVRImlGJ0YvRjIvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjkvJS9zdWJzY3JpcHRzaGlmdEdRIjBGJ0Y5LUY2Ni1RIitGJ0Y5RjtGPkZARkJGREZGRkhGVEZWLUYjNiQtSShtc3Vic3VwR0YkNidGY29GZm9GWS8lMXN1cGVyc2NyaXB0c2hpZnRHRmBwRl5wRjlGYXAtRmFvNiVGY28tRiM2JS1GIzYmRmhvRmFwLUZaNiRRIjFGJ0Y5RjlGW3BGOUZecEY5RltwRjk=">LCgqJkkjejFHNiIiIiImSSJ1R0YlNiNJImlHRiVGJiEiIyokRiciIiNGJiZGKDYjLCZGKkYmRiZGJkYm</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVEjZjJGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSM6PUYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUYjNiktRjY2LVEqJnVtaW51czA7RidGOUY7Rj5GQEZCRkRGRkZIL0ZLUSwwLjIyMjIyMjJlbUYnL0ZORlUtRiM2KC1JI21uR0YkNiRRIjJGJ0Y5LUY2Ni1RMSZJbnZpc2libGVUaW1lcztGJ0Y5RjtGPkZARkJGREZGRkgvRktRJjAuMGVtRicvRk5GW28tRiw2JVEjejJGJ0YvRjJGZ24tSSVtc3ViR0YkNiUtRiw2JVEidUYnRi9GMi1GIzYlLUYjNiYtRiw2JVEiaUYnRi9GMi1GNjYtUSIrRidGOUY7Rj5GQEZCRkRGRkZIRlRGVi1GWjYkUSIxRidGOUY5LyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5LyUvc3Vic2NyaXB0c2hpZnRHUSIwRidGOUZdcC1GIzYkLUkobXN1YnN1cEdGJDYnRmNvRmZvRlkvJTFzdXBlcnNjcmlwdHNoaWZ0R0ZocEZmcEY5Rl1wLUZhbzYlRmNvLUYjNiUtRiM2JkZqb0ZdcEZZRjlGY3BGOUZmcEY5RmNwRjk=">LCgqJkkjejJHNiIiIiImSSJ1R0YlNiMsJkkiaUdGJUYmRiZGJkYmISIjKiRGJyIiI0YmJkYoNiMsJkYrRiZGLkYmRiY=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVEjZjNGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSM6PUYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUYjNiktRjY2LVEqJnVtaW51czA7RidGOUY7Rj5GQEZCRkRGRkZIL0ZLUSwwLjIyMjIyMjJlbUYnL0ZORlUtRiM2JC1JJW1zdXBHRiQ2JS1GLDYlUSN6MUYnRi9GMi1JI21uR0YkNiRRIjJGJ0Y5LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0Y5LUY2Ni1RKCZtaW51cztGJ0Y5RjtGPkZARkJGREZGRkhGVEZWLUYjNiQtSShtc3Vic3VwR0YkNictRiw2JVEidUYnRi9GMi1GIzYlLUYsNiVRImlGJ0YvRjIvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjlGaW5GXW8vJS9zdWJzY3JpcHRzaGlmdEdGX29GOS1GNjYtUSIrRidGOUY7Rj5GQEZCRkRGRkZIRlRGVi1GLDYlUSN6MkYnRi9GMkY5RmBwRjk=">LCgqJEkjejFHNiIiIiMhIiIqJCZJInVHRiU2I0kiaUdGJUYmRidJI3oyR0YlIiIi</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L17" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">supp_hull :=`toric/polytope`([f1,f2,f3],[z1,z2]);</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVEqc3VwcF9odWxsRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEjOj1GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC1GIzYnLUkobWZlbmNlZEdGJDYmLUknbXRhYmxlR0YkNjUtSSRtdHJHRiQ2KC1JJG10ZEdGJDYoLUZSNiYtRiM2Jy1JI21uR0YkNiRRIjFGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRicvRk5RLDAuMzMzMzMzM2VtRictRlxvNiRRIjJGJ0Y5LyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5RjkvJSVvcGVuR1EifGZyRicvJSZjbG9zZUdRInxockYnLyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZlcC8lK2dyb3VwYWxpZ25HRmVwLyUocm93c3BhbkdGXm8vJStjb2x1bW5zcGFuR0Zeb0ZaLUZlbjYoLUZSNiYtRiM2KUZbb0Zfb0Znb0Zfby1GXG82JFEiM0YnRjlGam9GOUY5Rl1wRmBwRmNwRmZwRmhwRmpwRlxxRmNwRmZwRmhwLyUmYWxpZ25HUSVheGlzRicvRmRwUSliYXNlbGluZUYnL0ZncFEnY2VudGVyRicvRmlwUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGMS8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRmRyLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRl9zLyUmZnJhbWVHRl9zLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGPS8lLWVxdWFsY29sdW1uc0dGPS8lLWRpc3BsYXlzdHlsZUdGPS8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0Zcc0Y5L0ZecFEiW0YnL0ZhcFEiXUYnRl9vLUZSNiYtRlU2NS1GWDYoLUZlbjYoLUZSNiYtRiM2JS1GVTY2LUZYNictRmVuNigtRlxvNiRRIjBGJ0Y5RmNwRmZwRmhwRmpwRlxxLUZlbjYoRltvRmNwRmZwRmhwRmpwRlxxRmNwRmZwRmhwLUZYNidGZnVGZnVGY3BGZnBGaHBGZ3FGanEvRmdwRl90Rl5yRmByRmJyRmVyRmdyRmpyRl1zRmBzRmJzRmRzRmdzRmlzRlt0Rl10RmB0RmpvRjlGOUZidEZkdEZjcEZmcEZocEZqcEZccS1GZW42KC1GUjYmLUYjNiUtRlU2NkZddkZkdUZncUZqcUZfdkZeckZgckZickZlckZnckZqckZdc0Zgc0Zic0Zkc0Znc0Zpc0ZbdEZddEZgdEZqb0Y5RjlGYnRGZHRGY3BGZnBGaHBGanBGXHEtRmVuNigtRlI2Ji1GIzYlLUZVNjYtRlg2KEZmdUZmdS1GZW42KEZnb0ZjcEZmcEZocEZqcEZccUZjcEZmcEZocC1GWDYoRmZ1Rlt2RmZ1RmNwRmZwRmhwRmdxRmpxRl92Rl5yRmByRmJyRmVyRmdyRmpyRl1zRmBzRmJzRmRzRmdzRmlzRlt0Rl10RmB0RmpvRjlGOUZidEZkdEZjcEZmcEZocEZqcEZccUZjcEZmcEZocEZncUZqcUZcckZeckZgckZickZlckZnckZqckZdc0Zgc0Zic0Zkc0Znc0Zpc0ZbdEZddEZgdEY5RmJ0RmR0RmpvRjlGam9GOQ==">NiQ9NiI2IzsiIiIiIiRFXFtsJEYnPCRGJyIiI0YrRipGKDwlRidGK0YoPUYkRiVFXFtsJEYnPUYkNiQ7RidGK0YxRVxbbCU2JEYnRitGJzYkRidGJyIiITYkRitGJ0Y1NiRGK0YrRjVGKz1GJEYwRVxbbCVGM0Y1RjRGNUY2RjVGN0YnRig9RiQ2JEYxRiZFXFtsJzYkRidGKEYrRjNGNUY0RjVGNkY1RjdGJzYkRitGKEY1</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L18" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">`toric/mixed`(supp_hull[1], supp_hull[2],2);</Text-field>
</Input>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">computing numerator ONLY
toric/mixed(): Random Delta = -0.005000 0.017500
Random affine lifting =array(1 .. 3, 1 .. 3,[(3, 2)=897,(3, 3)=454,(1, 3)=940,(1, 2)=174,(1, 1)=362,(2, 1)=393,(2, 2)=845,(2, 3)=187,(3, 1)=656]).</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNictSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnBGaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RKWJhc2VsaW5lRicvRl1wUSdjZW50ZXJGJy9GX3BRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YzLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGZnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGYXIvJSZmcmFtZUdGYXIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y/LyUtZXF1YWxjb2x1bW5zR0Y/LyUtZGlzcGxheXN0eWxlR0Y/LyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRl5yRjsvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGVy1Gam42Ji1GIzYlLUZdbzY2LUZgbzYnLUZjbzYoLUZmbzYkUSIwRidGO0Zpb0ZccEZecEZgcEZicEZib0Zpb0ZccEZecC1GYG82J0ZidEZidEZpb0ZccEZecEZpcEZccS9GXXBGYXNGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGW3NGXXNGX3NGYnNGVEY7RjtGZHNGZ3NGVEY7">NiUtSSJARzYiNiRJLWh1bGxfdG9fc3VwcEdGJUkpaHVsbF9hcnJHRiU9RiU2IzsiIiIiIiNFXFtsI0YsRixGLUYtPUYlNiRGK0YrRVxbbCU2JEYsRi1GLDYkRixGLCIiITYkRi1GLEY0NiRGLUYtRjQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNictSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnBGaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RKWJhc2VsaW5lRicvRl1wUSdjZW50ZXJGJy9GX3BRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YzLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGZnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGYXIvJSZmcmFtZUdGYXIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y/LyUtZXF1YWxjb2x1bW5zR0Y/LyUtZGlzcGxheXN0eWxlR0Y/LyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRl5yRjsvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGVy1Gam42Ji1GIzYlLUZdbzY2LUZgbzYnLUZjbzYoLUZmbzYkUSIwRidGO0Zpb0ZccEZecEZgcEZicEZidEZpb0ZccEZecC1GYG82J0ZidEZib0Zpb0ZccEZecEZpcEZccS9GXXBGYXNGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGW3NGXXNGX3NGYnNGVEY7RjtGZHNGZ3NGVEY7">NiUtSSJARzYiNiRJLWh1bGxfdG9fc3VwcEdGJUkpaHVsbF9hcnJHRiU9RiU2IzsiIiIiIiNFXFtsI0YsRixGLUYtPUYlNiRGK0YrRVxbbCU2JEYsRi0iIiE2JEYsRixGMzYkRi1GLEYzNiRGLUYtRiw=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNigtSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnAtRmNvNigtRmZvNiRRIjNGJ0Y7RmlvRlxwRl5wRmBwRmJwRmlvRlxwRl5wLyUmYWxpZ25HUSVheGlzRicvRmpvUSliYXNlbGluZUYnL0ZdcFEnY2VudGVyRicvRl9wUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGMy8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRltyLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRmZyLyUmZnJhbWVHRmZyLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGPy8lLWVxdWFsY29sdW1uc0dGPy8lLWRpc3BsYXlzdHlsZUdGPy8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZjckY7LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRlctRmpuNiYtRiM2JS1GXW82Ni1GYG82KC1GY282KC1GZm82JFEiMEYnRjtGaW9GXHBGXnBGYHBGYnBGZ3RGZHBGaW9GXHBGXnAtRmBvNihGZ3RGYm9GZ3RGaW9GXHBGXnBGXnFGYXEvRl1wRmZzRmVxRmdxRmlxRlxyRl5yRmFyRmRyRmdyRmlyRltzRl5zRmBzRmJzRmRzRmdzRlRGO0Y7RmlzRlx0RlRGOw==">NiUtSSJARzYiNiRJLWh1bGxfdG9fc3VwcEdGJUkpaHVsbF9hcnJHRiU9RiU2IzsiIiIiIiRFXFtsJEYsRiwiIiNGL0YtRi09RiU2JDtGLEYvRitFXFtsJzYkRixGLUYvNiRGLEYvIiIhNiRGLEYsRjY2JEYvRixGNjYkRi9GL0YsNiRGL0YtRjY=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5000000000e-2,(2, 1)=-.1750000000e-1])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5000000000e-2, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = -.1750000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCI=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=-.9950000000,(2, 1)=-1.017500000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = -.9950000000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = -1.017500000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCI=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=-.9950000000,(2, 1)=-.1750000000e-1])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = -.9950000000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = -.1750000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCI=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=-.9950000000,(2, 1)=.9825000000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = -.9950000000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .9825000000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCI=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5000000000e-2,(2, 1)=-1.017500000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5000000000e-2, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = -1.017500000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCI=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5000000000e-2,(2, 1)=.9825000000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5000000000e-2, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .9825000000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKytdKiohIzUvSSdsYW0xeDJHRiQkIisrKysrXSEjNy9JJ2xhbTJ4MUdGJCQiKysrK108ISM2L0knbGFtMngyR0YkJCIrKysrRCkqRiovSSdsYW0zeDFHRiQkIiIiIiIhL0knbGFtM3gyR0YkJEY9Rj0vSSdsYW0zeDNHRiRGQA==</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Passing start vertex=array(1 .. 2, 1 .. 1,[(1, 1)=0,(2, 1)=1]).
greedy search for row indices</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYrLUkobWZlbmNlZEdGJDYmLUknbXRhYmxlR0YkNjUtSSRtdHJHRiQ2KC1JJG10ZEdGJDYoLUYsNiYtRiM2JS1GLzY2LUYyNictRjU2KC1JI21uR0YkNiRRIjBGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRicvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRkovJStncm91cGFsaWduR0ZKLyUocm93c3BhbkdRIjFGJy8lK2NvbHVtbnNwYW5HRlEtRjU2KC1GQjYkRlFGRUZIRktGTUZPRlJGSEZLRk0tRjI2J0Y/Rj9GSEZLRk0vJSZhbGlnbkdRJWF4aXNGJy9GSVEpYmFzZWxpbmVGJy9GTFEmcmlnaHRGJy9GTlEnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHUSV0cnVlRicvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0Ziby8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZdcC8lJmZyYW1lR0ZdcC8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHUSZmYWxzZUYnLyUtZXF1YWxjb2x1bW5zR0ZncC8lLWRpc3BsYXlzdHlsZUdGZ3AvJSVzaWRlR0Zqbi8lMG1pbmxhYmVsc3BhY2luZ0dGam8vJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRkVGRS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0ZIRktGTUZPRlItRjU2KC1GLDYmLUYjNiUtRi82NkZYRj1GWkZnbkZpbkZbb0Zdb0Zgb0Zjb0Zlb0Zob0ZbcEZecEZgcEZicEZlcEZocEZqcEZccUZecUZgcUZFRkVGY3FGZnFGSEZLRk1GT0ZSLUY1NigtRiw2Ji1GIzYlLUYvNjYtRjI2KEY/Rj8tRjU2KC1GQjYkUSIyRidGRUZIRktGTUZPRlJGSEZLRk0tRjI2KEY/RlRGP0ZIRktGTUZaRmduRmluRltvRl1vRmBvRmNvRmVvRmhvRltwRl5wRmBwRmJwRmVwRmhwRmpwRlxxRl5xRmBxRkVGRUZjcUZmcUZIRktGTUZPRlJGSEZLRk1GWkZnbi9GTFEnY2VudGVyRidGW29GXW9GYG9GY29GZW9GaG9GW3BGXnBGYHBGYnBGZXBGaHBGanBGXHFGXnFGRUZjcUZmcS1JI21vR0YkNi1RIixGJ0ZFLyUmZmVuY2VHRmdwLyUqc2VwYXJhdG9yR0Zfby8lKXN0cmV0Y2h5R0ZncC8lKnN5bW1ldHJpY0dGZ3AvJShsYXJnZW9wR0ZncC8lLm1vdmFibGVsaW1pdHNHRmdwLyUnYWNjZW50R0ZncC8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnRitGZHMtRiw2Ji1GIzYrLUYjNiwtRiM2Ji1GQjYkUSQzNjJGJ0ZFLUZlczYtUTEmSW52aXNpYmxlVGltZXM7RidGRUZocy9GW3RGZ3BGXHRGXnRGYHRGYnRGZHRGZnQvRmp0Rmh0LUkjbWlHRiQ2JVEnbGFtMXgyRicvJSdpdGFsaWNHRl9vL0ZGUSdpdGFsaWNGJ0ZFLUZlczYtUSIrRidGRUZoc0ZqdUZcdEZedEZgdEZidEZkdC9GZ3RRLDAuMjIyMjIyMmVtRicvRmp0Rmh2LUZCNiRRJTE1ODFGJ0ZFRmR2LUYjNiYtRkI2JFEkODQ1RidGRUZndS1GXXY2JVEnbGFtMngyRidGYHZGYnZGRUZkdi1GIzYmLUZCNiRRJTEzMTJGJ0ZFRmd1LUZddjYlUSdsYW0zeDNGJ0ZgdkZidkZFRmR2LUYjNiYtRkI2JFEkODk3RidGRUZndS1GXXY2JVEnbGFtM3gyRidGYHZGYnZGRUZFRmRzLUYsNiYtRiM2KS1GIzYnLUYjNiYtRl12NiVRJ2xhbTF4MUYnRmB2RmJ2RmR2Rlx2RkUtRmVzNi1RIj1GJ0ZFRmhzRmp1Rlx0Rl50RmB0RmJ0RmR0L0ZndFEsMC4yNzc3Nzc4ZW1GJy9GanRGZHlGVkZgcUZFRmRzLUYjNictRiM2Ji1GXXY2JVEnbGFtMngxRidGYHZGYnZGZHZGYndGRUZgeUZWRmBxRkVGZHMtRiM2Jy1GIzYoLUZddjYlUSdsYW0zeDFGJ0ZgdkZidkZkdkZieEZkdkZqd0ZFRmB5RlZGYHFGRUZgcUZFRkUvRmRxUSJ8ZnJGJy9GZ3FRInxockYnRmRzLUZddjYlUSh2ZXJ0bGhzRidGYHZGYnZGZHMtRkI2JFEiN0YnRkVGYHFGRUZFRmNxRmZxRmRzLUYsNiYtRi82NS1GMjYnLUY1NigtRiM2JS1GZXM2LVEqJnVtaW51czA7RidGRUZoc0ZqdUZcdEZedEZgdEZidEZkdEZndkZpdi1GQjYkUS8wLjAwNTAwMDAwMDAwMEYnRkVGRUZIRktGTUZPRlItRjU2KC1GQjYkUS4wLjAxNzUwMDAwMDAwRidGRUZIRktGTUZPRlJGSEZLRk1GWkZnbkZic0Zbb0Zdb0Zgb0Zjb0Zlb0Zob0ZbcEZecEZgcEZicEZlcEZocEZqcEZccUZecUZFRmNxRmZxRmBxRkU=">NiY9NiI2IzsiIiIiIiRFXFtsJEYnPUYkNiQ7RiciIiNGLEVcW2wlNiRGJ0YtRic2JEYnRiciIiE2JEYtRidGMTYkRi1GLUYxRi09RiRGK0VcW2wlRi9GMUYwRjFGMkYxRjNGJ0YoPUYkNiRGLEYmRVxbbCc2JEYnRihGLUYvRjFGMEYxRjJGMUYzRic2JEYtRihGMUYjNyYsLEknbGFtMXgyR0YkIiRpJCIlImUiRidJJ2xhbTJ4MkdGJCIkWClJJ2xhbTN4M0dGJCIlNzhJJ2xhbTN4MkdGJCIkKCopPCUvLCZJJ2xhbTF4MUdGJEYnRj1GJ0YnLywmSSdsYW0yeDFHRiRGJ0ZARidGJy8sKEknbGFtM3gxR0YkRidGREYnRkJGJ0YnSSh2ZXJ0bGhzR0YkIiIoSSZkZWx0YUdGJA==</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`  maximum coordinates`, array( 1 .. 2, [( 1 ) = (3), ( 2 ) = (2)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5000000000e-2,(2, 1)=.9825000000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5000000000e-2, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .9825000000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKytdKiohIzUvSSdsYW0xeDJHRiQkIisrKysrXSEjNy9JJ2xhbTJ4MUdGJCQiKysrK108ISM2L0knbGFtMngyR0YkJCIrKysrRCkqRiovSSdsYW0zeDFHRiQkIiIiIiIhL0knbGFtM3gyR0YkJEY9Rj0vSSdsYW0zeDNHRiRGQA==</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIxRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMEYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR0ZTLyUrY29sdW1uc3BhbkdGU0Zib0Zlb0Znby1Gam42Ji1GXW82KEZQRmJvRmVvRmdvRmlvRltwRmJvRmVvRmdvLyUmYWxpZ25HUSVheGlzRicvRmNvUSliYXNlbGluZUYnL0Zmb1EmcmlnaHRGJy9GaG9RJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YxLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGXnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGaXEvJSZmcmFtZUdGaXEvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y9LyUtZXF1YWxjb2x1bW5zR0Y9LyUtZGlzcGxheXN0eWxlR0Y9LyUlc2lkZUdGZ3AvJTBtaW5sYWJlbHNwYWNpbmdHRmZxLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGNS1GLDYlUSpleHByZXNzZWRGJ0YvRjJGNS1GWDYmLUZnbjY1LUZqbjYoRlxvRlxvRl9wRmJvRmVvRmdvRmFwRmRwL0Zmb1EnY2VudGVyRidGaHBGanBGXHFGX3FGYXFGZHFGZ3FGanFGXHJGXnJGYXJGY3JGZXJGZ3JGaXJGOUZec0Zhc0Zbc0Y5">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiJJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 3, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (0), ( 2, 1 ) = (1)  ] ), array( 1 .. 3, [( 1 ) = (0), ( 2 ) = (0), ( 3 ) = (1)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=2.005000000,(2, 1)=.9825000000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = 2.005000000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .9825000000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIiIhRikvSSdsYW0xeDJHRiQkIisrKysrNSEiKi9JJ2xhbTJ4MUdGJCQiKysrK108ISM2L0knbGFtMngyR0YkJCIrKysrRCkqISM1L0knbGFtM3gxR0YkJCIrKysrdlxGOC9JJ2xhbTN4MkdGJEYoL0knbGFtM3gzR0YkJCIrKysrRF1GOA==</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIyRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNihGUC8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGYW8vJStncm91cGFsaWduR0Zhby8lKHJvd3NwYW5HUSIxRicvJStjb2x1bW5zcGFuR0Zob0Zfb0Zib0Zkby1Gam42Ji1GXW82KC1GUTYkRmhvRjlGX29GYm9GZG9GZm9GaW9GX29GYm9GZG8vJSZhbGlnbkdRJWF4aXNGJy9GYG9RKWJhc2VsaW5lRicvRmNvUSZyaWdodEYnL0Zlb1EnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHRjEvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0ZecS8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZpcS8lJmZyYW1lR0ZpcS8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHRj0vJS1lcXVhbGNvbHVtbnNHRj0vJS1kaXNwbGF5c3R5bGVHRj0vJSVzaWRlR0ZncC8lMG1pbmxhYmVsc3BhY2luZ0dGZnEvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Y1LUYsNiVRKmV4cHJlc3NlZEYnRi9GMkY1LUZYNiYtRmduNjUtRmpuNihGXG8tRl1vNigtRlE2JFEiMEYnRjlGX29GYm9GZG9GZm9GaW9GXXRGX29GYm9GZG9GYXBGZHAvRmNvUSdjZW50ZXJGJ0ZocEZqcEZccUZfcUZhcUZkcUZncUZqcUZcckZeckZhckZjckZlckZnckZpckY5Rl5zRmFzRltzRjk=">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiNJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 1, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (2), ( 2, 1 ) = (1)  ] ), array( 1 .. 3, [( 1 ) = (2), ( 2 ) = (0), ( 3 ) = (0)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=1.005000000,(2, 1)=.9825000000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = 1.005000000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .9825000000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIiIhRikvSSdsYW0xeDJHRiQkIisrKysrNSEiKi9JJ2xhbTJ4MUdGJCQiKysrK108ISM2L0knbGFtMngyR0YkJCIrKysrRCkqISM1L0knbGFtM3gxR0YkJCIrKysrdioqRjgvSSdsYW0zeDJHRiRGKC9JJ2xhbTN4M0dGJCQiKysrKytEISM3</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIzRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMUYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR0Zhby8lK2NvbHVtbnNwYW5HRmFvRmJvRmVvRmdvRmluLyUmYWxpZ25HUSVheGlzRicvRmNvUSliYXNlbGluZUYnL0Zmb1EmcmlnaHRGJy9GaG9RJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YxLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGanAvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGZXEvJSZmcmFtZUdGZXEvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y9LyUtZXF1YWxjb2x1bW5zR0Y9LyUtZGlzcGxheXN0eWxlR0Y9LyUlc2lkZUdGY3AvJTBtaW5sYWJlbHNwYWNpbmdHRmJxLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGNS1GLDYlUSpleHByZXNzZWRGJ0YvRjJGNS1GWDYmLUZnbjY1LUZqbjYoLUZdbzYoLUZRNiRRIjJGJ0Y5RmJvRmVvRmdvRmlvRltwLUZdbzYoLUZRNiRRIjBGJ0Y5RmJvRmVvRmdvRmlvRltwRl50RmJvRmVvRmdvRl1wRmBwL0Zmb1EnY2VudGVyRidGZHBGZnBGaHBGW3FGXXFGYHFGY3FGZnFGaHFGanFGXXJGX3JGYXJGY3JGZXJGOUZqckZdc0ZnckY5">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiRJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 1, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (1), ( 2, 1 ) = (1)  ] ), array( 1 .. 3, [( 1 ) = (2), ( 2 ) = (0), ( 3 ) = (0)  ] )</Text-field>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5000000000e-2,(2, 1)=1.982500000])
   obj.fnc=362*lam1x2+1581+845*lam2x2+1312*lam3x3+897*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5000000000e-2, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = 1.982500000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKytdKiohIzUvSSdsYW0xeDJHRiQkIisrKysrXSEjNy9JJ2xhbTJ4MUdGJCQiIiFGMy9JJ2xhbTJ4MkdGJCQiKysrKys1ISIqL0knbGFtM3gxR0YkJCIrKysrXTwhIzYvSSdsYW0zeDJHRiQkIisrKytEKSpGKi9JJ2xhbTN4M0dGJEYy</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSI0RidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMEYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGW3BGYm9GZW9GZ28tRmpuNiYtRl1vNigtRlE2JFEiMkYnRjlGYm9GZW9GZ29GaW9GXHBGYm9GZW9GZ28vJSZhbGlnbkdRJWF4aXNGJy9GY29RKWJhc2VsaW5lRicvRmZvUSZyaWdodEYnL0Zob1EnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHRjEvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0ZicS8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0Zdci8lJmZyYW1lR0Zdci8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHRj0vJS1lcXVhbGNvbHVtbnNHRj0vJS1kaXNwbGF5c3R5bGVHRj0vJSVzaWRlR0ZbcS8lMG1pbmxhYmVsc3BhY2luZ0dGanEvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Y1LUYsNiVRKmV4cHJlc3NlZEYnRi9GMkY1LUZYNiYtRmduNjUtRmpuNihGXG9GYHBGXG9GYm9GZW9GZ29GZXBGaHAvRmZvUSdjZW50ZXJGJ0ZccUZecUZgcUZjcUZlcUZocUZbckZeckZgckZickZlckZnckZpckZbc0Zdc0Y5RmJzRmVzRl9zRjk=">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiVJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 2, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (0), ( 2, 1 ) = (2)  ] ), array( 1 .. 3, [( 1 ) = (0), ( 2 ) = (2), ( 3 ) = (0)  ] )
toric/mixed(): constructing 4-dim matrix
Subdivision resultant matrix of size 4 x 4.
timings[secs] and percents:
optimize=.62e-1s (66%), find rows=.31e-1s (33%),construct=0.s ( 0%), total=.94e-1s
mixed returning [numM,denM],[pts,RC],supps,diagMons,denom_rows</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYtLUkobWZlbmNlZEdGJDYmLUYjNictRiw2Ji1GIzYlLUknbXRhYmxlR0YkNjgtSSRtdHJHRiQ2KS1JJG10ZEdGJDYoLUkjbWlHRiQ2JVElYzN4MUYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGSS8lK2dyb3VwYWxpZ25HRkkvJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGUC1GOzYoLUY+NiVRJWMzeDJGJ0ZBRkRGR0ZKRkxGTkZRLUY7NigtSSNtbkdGJDYkUSIwRicvRkVRJ25vcm1hbEYnRkdGSkZMRk5GUS1GOzYoLUY+NiVRJWMzeDNGJ0ZBRkRGR0ZKRkxGTkZRRkdGSkZMLUY4NiktRjs2KC1GPjYlUSVjMngxRidGQUZERkdGSkZMRk5GUS1GOzYoLUY+NiVRJWMyeDJGJ0ZBRkRGR0ZKRkxGTkZRRlhGWEZHRkpGTC1GODYpLUY7NigtRj42JVElYzF4MUYnRkFGREZHRkpGTEZORlFGWC1GOzYoLUY+NiVRJWMxeDJGJ0ZBRkRGR0ZKRkxGTkZRRlhGR0ZKRkwtRjg2KUZYRlhGXXBGYnBGR0ZKRkwvJSZhbGlnbkdRJWF4aXNGJy9GSFEpYmFzZWxpbmVGJy9GS1EnY2VudGVyRicvRk1RJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0ZDLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGZnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGYXIvJSZmcmFtZUdGYXIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR1EmZmFsc2VGJy8lLWVxdWFsY29sdW1uc0dGW3MvJS1kaXNwbGF5c3R5bGVHRltzLyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRl5yLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0ZobkZobi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1JI21vR0YkNi1RIixGJ0Zobi8lJmZlbmNlR0Zbcy8lKnNlcGFyYXRvckdGQy8lKXN0cmV0Y2h5R0Zbcy8lKnN5bW1ldHJpY0dGW3MvJShsYXJnZW9wR0Zbcy8lLm1vdmFibGVsaW1pdHNHRltzLyUnYWNjZW50R0Zbcy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUYsNiYtRiM2JS1GNTY1LUY4NiYtRjs2KC1GPjYlRklGQUZERkdGSkZMRk5GUUZHRkpGTEZpcEZccS9GS0Zic0ZgcUZicUZkcUZncUZpcUZcckZfckZickZkckZmckZpckZcc0Zec0Zgc0Zjc0Zlc0ZobkZobkZoc0ZbdEZlc0ZobkZobkZoc0ZbdEZedC1GLDYmLUYjNistRiw2Ji1GIzYpLUYsNiYtRiM2JS1GNTY2LUY4NiZGWEZHRkpGTC1GODYmLUY7NigtRmVuNiRGUEZobkZHRkpGTEZORlFGR0ZKRkxGaXBGXHFGYnZGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGXHNGXnNGYHNGY3NGZXNGaG5GaG5GaHNGW3RGXnQtRmVuNiRRIjNGJ0ZobkZedEZnd0Zlc0ZobkZobkZoc0ZbdEZedC1GLDYmLUYjNiktRiw2Ji1GIzYlLUY1NjZGYXctRjg2Ji1GOzYoLUZlbjYkUSIyRidGaG5GR0ZKRkxGTkZRRkdGSkZMRmlwRlxxRmJ2RmBxRmJxRmRxRmdxRmlxRlxyRl9yRmJyRmRyRmZyRmlyRlxzRl5zRmBzRmNzRmVzRmhuRmhuRmhzRlt0Rl50Rmp4Rl50Rmp4RmVzRmhuRmhuRmhzRlt0Rl50LUYsNiYtRiM2KS1GLDYmLUYjNiUtRjU2NkZjd0Zjd0ZpcEZccUZidkZgcUZicUZkcUZncUZpcUZcckZfckZickZkckZmckZpckZcc0Zec0Zgc0Zjc0Zlc0ZobkZobkZoc0ZbdEZedEZnd0ZedEZqeEZlc0ZobkZobkZoc0ZbdEZedC1GLDYmLUYjNiktRiw2Ji1GIzYlLUY1NjZGZnhGY3dGaXBGXHFGYnZGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGXHNGXnNGYHNGY3NGZXNGaG5GaG5GaHNGW3RGXnRGZ3dGXnRGanhGZXNGaG5GaG5GaHNGW3RGZXNGaG5GaG5GaHNGW3RGXnQtRiw2Ji1GNTY1LUY4NigtRjs2KC1GLDYmLUYjNiUtRjU2Ni1GODYnRlhGZXdGR0ZKRkwtRjg2J0ZYRlhGR0ZKRkxGaXBGXHFGYnZGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGXHNGXnNGYHNGY3NGZXNGaG5GaG5GaHNGW3RGR0ZKRkxGTkZRLUY7NigtRiw2Ji1GIzYlLUY1NjZGYVtsRl9bbEZpcEZccUZidkZgcUZicUZkcUZncUZpcUZcckZfckZickZkckZmckZpckZcc0Zec0Zgc0Zjc0Zlc0ZobkZobkZoc0ZbdEZHRkpGTEZORlEtRjs2KC1GLDYmLUYjNiUtRjU2Ni1GODYoRlhGWEZoeEZHRkpGTC1GODYoRlhGZXdGWEZHRkpGTEZpcEZccUZidkZgcUZicUZkcUZncUZpcUZcckZfckZickZkckZmckZpckZcc0Zec0Zgc0Zjc0Zlc0ZobkZobkZoc0ZbdEZHRkpGTEZORlFGR0ZKRkxGaXBGXHFGXnFGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGXHNGXnNGYHNGY3NGaG5GaHNGW3RGXnQtRiw2Ji1GNTY1LUY4NigtRjs2KC1GLDYmLUYjNiVGanhGZXNGaG5GaG4vRmlzUSJ8ZnJGJy9GXHRRInxockYnRkdGSkZMRk5GUUZdXWwtRjs2KC1GLDYmLUYjNiVGZ3dGZXNGaG5GaG5GY11sRmVdbEZHRkpGTEZORlFGR0ZKRkxGaXBGXHFGXnFGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGXHNGXnNGYHNGY3NGaG5GaHNGW3RGXnQtRiw2Ji1GIzYlRmB2RmVzRmhuRmhuRmhzRlt0RmVzRmhu">Nic3JD02IjYkOyIiIiIiJUYnRVxbbDE2JCIiJCIiIyIiITYkRixGLEklYzF4MkdGJTYkRilGLUYuNiRGKUYsSSVjMXgxR0YlNiRGKUYoRi42JEYsRilGLjYkRihGLEYuNiRGKEYtSSVjM3gyR0YlNiRGKEYoSSVjM3gxR0YlNiRGLUYpRi42JEYtRihJJWMyeDFHRiU2JEYtRi1JJWMyeDJHRiU2JEYoRilJJWMzeDNHRiU2JEYpRilGMDYkRi1GLEYuNiRGLEYoRjM9RiU2JDtGKEYuRkdFXFtsITcmNyU9RiU2JDtGKEYtO0YoRihFXFtsI0Y5Ri5GPEYoRixGKDclPUYlRkxFXFtsI0Y5Ri5GPEYtRi1GLTclPUYlRkxFXFtsI0Y5RihGPEYoRihGLTclPUYlRkxFXFtsI0Y5Ri1GPEYoRihGLT1GJTYjO0YoRixFXFtsJEYoPUYlNiRGTUZNRVxbbCVGN0YoRjlGLkY8Ri5GPkYuRi09RiVGaG5FXFtsJUY3Ri5GOUYuRjxGLkY+RihGLD1GJTYkRk1GZW5FXFtsJ0Y2Ri1GN0YuRjlGLkY8Ri5GPkYoRkNGLj1GJUZaRVxbbCRGKDwjRi1GLUZhb0YsPCNGKDci</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L19" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">spresultant([f1,f2,f3],[z1,z2]);</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkobWZlbmNlZEdGJDYmLUknbXRhYmxlR0YkNjUtSSRtdHJHRiQ2KC1JJG10ZEdGJDYoLUYsNiYtRiM2Jy1JI21uR0YkNiRRIjFGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUSIsRidGPy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0ZILyUqc3ltbWV0cmljR0ZILyUobGFyZ2VvcEdGSC8lLm1vdmFibGVsaW1pdHNHRkgvJSdhY2NlbnRHRkgvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GPDYkUSIyRidGPy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRidGP0Y/LyUlb3BlbkdRInxmckYnLyUmY2xvc2VHUSJ8aHJGJy8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGZG8vJStncm91cGFsaWduR0Zkby8lKHJvd3NwYW5HRj4vJStjb2x1bW5zcGFuR0Y+RjQtRjU2KC1GLDYmLUYjNilGO0ZCRmZuRkItRjw2JFEiM0YnRj9GaW5GP0Y/RlxvRl9vRmJvRmVvRmdvRmlvRltwRmJvRmVvRmdvLyUmYWxpZ25HUSVheGlzRicvRmNvUSliYXNlbGluZUYnL0Zmb1EnY2VudGVyRicvRmhvUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGSy8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRmNxLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRl5yLyUmZnJhbWVHRl5yLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGSC8lLWVxdWFsY29sdW1uc0dGSC8lLWRpc3BsYXlzdHlsZUdGSC8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZbckY/L0Zdb1EiW0YnL0Zgb1EiXUYnRkItRiw2Ji1GLzY1LUYyNigtRjU2KC1GLDYmLUYjNiUtRi82Ni1GMjYnLUY1NigtRjw2JFEiMEYnRj9GYm9GZW9GZ29GaW9GW3AtRjU2KEY7RmJvRmVvRmdvRmlvRltwRmJvRmVvRmdvLUYyNidGZXRGZXRGYm9GZW9GZ29GZnBGaXAvRmZvRl5zRl1xRl9xRmFxRmRxRmZxRmlxRlxyRl9yRmFyRmNyRmZyRmhyRmpyRlxzRl9zRmluRj9GP0Zhc0Zjc0Zib0Zlb0Znb0Zpb0ZbcC1GNTYoLUYsNiYtRiM2JS1GLzY2Rlx1RmN0RmZwRmlwRl51Rl1xRl9xRmFxRmRxRmZxRmlxRlxyRl9yRmFyRmNyRmZyRmhyRmpyRlxzRl9zRmluRj9GP0Zhc0Zjc0Zib0Zlb0Znb0Zpb0ZbcC1GNTYoLUYsNiYtRiM2JS1GLzY2LUYyNihGZXRGZXQtRjU2KEZmbkZib0Zlb0Znb0Zpb0ZbcEZib0Zlb0Znby1GMjYoRmV0Rmp0RmV0RmJvRmVvRmdvRmZwRmlwRl51Rl1xRl9xRmFxRmRxRmZxRmlxRlxyRl9yRmFyRmNyRmZyRmhyRmpyRlxzRl9zRmluRj9GP0Zhc0Zjc0Zib0Zlb0Znb0Zpb0ZbcEZib0Zlb0Znb0ZmcEZpcEZbcUZdcUZfcUZhcUZkcUZmcUZpcUZcckZfckZhckZjckZmckZockZqckZcc0Zfc0Y/RmFzRmNzRmluRj8=">NiQ9NiI2IzsiIiIiIiRFXFtsJEYnPCRGJyIiI0YrRipGKDwlRidGK0YoPUYkRiVFXFtsJEYnPUYkNiQ7RidGK0YxRVxbbCU2JEYnRitGJzYkRidGJyIiITYkRitGJ0Y1NiRGK0YrRjVGKz1GJEYwRVxbbCVGM0Y1RjRGNUY2RjVGN0YnRig9RiQ2JEYxRiZFXFtsJzYkRidGKEYrRjNGNUY0RjVGNkY1RjdGJzYkRitGKEY1</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">computing numerator ONLY
toric/mixed(): Random Delta = -0.058500 -0.029700
Random affine lifting =array(1 .. 3, 1 .. 3,[(3, 2)=521,(3, 3)=762,(1, 3)=781,(1, 2)=172,(1, 1)=772,(2, 1)=147,(2, 2)=266,(2, 3)=143,(3, 1)=704]).</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNictSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnBGaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RKWJhc2VsaW5lRicvRl1wUSdjZW50ZXJGJy9GX3BRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YzLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGZnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGYXIvJSZmcmFtZUdGYXIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y/LyUtZXF1YWxjb2x1bW5zR0Y/LyUtZGlzcGxheXN0eWxlR0Y/LyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRl5yRjsvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGVy1Gam42Ji1GIzYlLUZdbzY2LUZgbzYnLUZjbzYoLUZmbzYkUSIwRidGO0Zpb0ZccEZecEZgcEZicEZib0Zpb0ZccEZecC1GYG82J0ZidEZidEZpb0ZccEZecEZpcEZccS9GXXBGYXNGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGW3NGXXNGX3NGYnNGVEY7RjtGZHNGZ3NGVEY7">NiUtSSJARzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiRJLWh1bGxfdG9fc3VwcEdGKEkpaHVsbF9hcnJHRig9Rig2IzsiIiIiIiNFXFtsI0YvRi9GMEYwPUYoNiRGLkYuRVxbbCU2JEYvRjBGLzYkRi9GLyIiITYkRjBGL0Y3NiRGMEYwRjc=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNictSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnBGaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RKWJhc2VsaW5lRicvRl1wUSdjZW50ZXJGJy9GX3BRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YzLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGZnEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGYXIvJSZmcmFtZUdGYXIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y/LyUtZXF1YWxjb2x1bW5zR0Y/LyUtZGlzcGxheXN0eWxlR0Y/LyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRl5yRjsvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGVy1Gam42Ji1GIzYlLUZdbzY2LUZgbzYnLUZjbzYoLUZmbzYkUSIwRidGO0Zpb0ZccEZecEZgcEZicEZidEZpb0ZccEZecC1GYG82J0ZidEZib0Zpb0ZccEZecEZpcEZccS9GXXBGYXNGYHFGYnFGZHFGZ3FGaXFGXHJGX3JGYnJGZHJGZnJGaXJGW3NGXXNGX3NGYnNGVEY7RjtGZHNGZ3NGVEY7">NiUtSSJARzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiRJLWh1bGxfdG9fc3VwcEdGKEkpaHVsbF9hcnJHRig9Rig2IzsiIiIiIiNFXFtsI0YvRi9GMEYwPUYoNiRGLkYuRVxbbCU2JEYvRjAiIiE2JEYvRi9GNjYkRjBGL0Y2NiRGMEYwRi8=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUYjNictSSNtaUdGJDYlUS1odWxsX3RvX3N1cHBGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSJARicvRjVRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y/LyUpc3RyZXRjaHlHRj8vJSpzeW1tZXRyaWNHRj8vJShsYXJnZW9wR0Y/LyUubW92YWJsZWxpbWl0c0dGPy8lJ2FjY2VudEdGPy8lJ2xzcGFjZUdRLDAuMTExMTExMWVtRicvJSdyc3BhY2VHRk4tRi42JVEpaHVsbF9hcnJGJ0YxRjQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjstRjg2LVEiLEYnRjtGPS9GQUYzRkJGREZGRkhGSi9GTVEmMC4wZW1GJy9GUFEsMC4zMzMzMzMzZW1GJy1JKG1mZW5jZWRHRiQ2Ji1JJ210YWJsZUdGJDY1LUkkbXRyR0YkNigtSSRtdGRHRiQ2KC1JI21uR0YkNiRRIjFGJ0Y7LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZbcC8lK2dyb3VwYWxpZ25HRltwLyUocm93c3BhbkdGaG8vJStjb2x1bW5zcGFuR0Zoby1GY282KC1GZm82JFEiMkYnRjtGaW9GXHBGXnBGYHBGYnAtRmNvNigtRmZvNiRRIjNGJ0Y7RmlvRlxwRl5wRmBwRmJwRmlvRlxwRl5wLyUmYWxpZ25HUSVheGlzRicvRmpvUSliYXNlbGluZUYnL0ZdcFEnY2VudGVyRicvRl9wUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGMy8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRltyLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRmZyLyUmZnJhbWVHRmZyLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGPy8lLWVxdWFsY29sdW1uc0dGPy8lLWRpc3BsYXlzdHlsZUdGPy8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZjckY7LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRlctRmpuNiYtRiM2JS1GXW82Ni1GYG82KC1GY282KC1GZm82JFEiMEYnRjtGaW9GXHBGXnBGYHBGYnBGZ3RGZHBGaW9GXHBGXnAtRmBvNihGZ3RGYm9GZ3RGaW9GXHBGXnBGXnFGYXEvRl1wRmZzRmVxRmdxRmlxRlxyRl5yRmFyRmRyRmdyRmlyRltzRl5zRmBzRmJzRmRzRmdzRlRGO0Y7RmlzRlx0RlRGOw==">NiUtSSJARzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiRJLWh1bGxfdG9fc3VwcEdGKEkpaHVsbF9hcnJHRig9Rig2IzsiIiIiIiRFXFtsJEYvRi8iIiNGMkYwRjA9Rig2JDtGL0YyRi5FXFtsJzYkRi9GMEYyNiRGL0YyIiIhNiRGL0YvRjk2JEYyRi9GOTYkRjJGMkYvNiRGMkYwRjk=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5850000000e-1,(2, 1)=.2970000000e-1])
   obj.fnc=772*lam1x2+1686+266*lam2x2+1408*lam3x3+521*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5850000000e-1, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .2970000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKysrNSEiKi9JJ2xhbTF4MkdGJCQiIiFGLi9JJ2xhbTJ4MUdGJCQiKysrKy4oKiEjNS9JJ2xhbTJ4MkdGJCQiKysrK3FIISM2L0knbGFtM3gxR0YkJCIrKytdMigqRjMvSSdsYW0zeDJHRiRGLS9JJ2xhbTN4M0dGJCQiKysrK0RIRjg=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">Passing start vertex=array(1 .. 2, 1 .. 1,[(1, 1)=0,(2, 1)=0]).
greedy search for row indices</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYrLUkobWZlbmNlZEdGJDYmLUknbXRhYmxlR0YkNjUtSSRtdHJHRiQ2KC1JJG10ZEdGJDYoLUYsNiYtRiM2JS1GLzY2LUYyNictRjU2KC1JI21uR0YkNiRRIjBGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRicvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRkovJStncm91cGFsaWduR0ZKLyUocm93c3BhbkdRIjFGJy8lK2NvbHVtbnNwYW5HRlEtRjU2KC1GQjYkRlFGRUZIRktGTUZPRlJGSEZLRk0tRjI2J0Y/Rj9GSEZLRk0vJSZhbGlnbkdRJWF4aXNGJy9GSVEpYmFzZWxpbmVGJy9GTFEmcmlnaHRGJy9GTlEnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHUSV0cnVlRicvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0Ziby8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZdcC8lJmZyYW1lR0ZdcC8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHUSZmYWxzZUYnLyUtZXF1YWxjb2x1bW5zR0ZncC8lLWRpc3BsYXlzdHlsZUdGZ3AvJSVzaWRlR0Zqbi8lMG1pbmxhYmVsc3BhY2luZ0dGam8vJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRkVGRS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0ZIRktGTUZPRlItRjU2KC1GLDYmLUYjNiUtRi82NkZYRj1GWkZnbkZpbkZbb0Zdb0Zgb0Zjb0Zlb0Zob0ZbcEZecEZgcEZicEZlcEZocEZqcEZccUZecUZgcUZFRkVGY3FGZnFGSEZLRk1GT0ZSLUY1NigtRiw2Ji1GIzYlLUYvNjYtRjI2KEY/Rj8tRjU2KC1GQjYkUSIyRidGRUZIRktGTUZPRlJGSEZLRk0tRjI2KEY/RlRGP0ZIRktGTUZaRmduRmluRltvRl1vRmBvRmNvRmVvRmhvRltwRl5wRmBwRmJwRmVwRmhwRmpwRlxxRl5xRmBxRkVGRUZjcUZmcUZIRktGTUZPRlJGSEZLRk1GWkZnbi9GTFEnY2VudGVyRidGW29GXW9GYG9GY29GZW9GaG9GW3BGXnBGYHBGYnBGZXBGaHBGanBGXHFGXnFGRUZjcUZmcS1JI21vR0YkNi1RIixGJ0ZFLyUmZmVuY2VHRmdwLyUqc2VwYXJhdG9yR0Zfby8lKXN0cmV0Y2h5R0ZncC8lKnN5bW1ldHJpY0dGZ3AvJShsYXJnZW9wR0ZncC8lLm1vdmFibGVsaW1pdHNHRmdwLyUnYWNjZW50R0ZncC8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnRitGZHMtRiw2Ji1GIzYrLUYjNiwtRiM2Ji1GQjYkUSQ3NzJGJ0ZFLUZlczYtUTEmSW52aXNpYmxlVGltZXM7RidGRUZocy9GW3RGZ3BGXHRGXnRGYHRGYnRGZHRGZnQvRmp0Rmh0LUkjbWlHRiQ2JVEnbGFtMXgyRicvJSdpdGFsaWNHRl9vL0ZGUSdpdGFsaWNGJ0ZFLUZlczYtUSIrRidGRUZoc0ZqdUZcdEZedEZgdEZidEZkdC9GZ3RRLDAuMjIyMjIyMmVtRicvRmp0Rmh2LUZCNiRRJTE2ODZGJ0ZFRmR2LUYjNiYtRkI2JFEkMjY2RidGRUZndS1GXXY2JVEnbGFtMngyRidGYHZGYnZGRUZkdi1GIzYmLUZCNiRRJTE0MDhGJ0ZFRmd1LUZddjYlUSdsYW0zeDNGJ0ZgdkZidkZFRmR2LUYjNiYtRkI2JFEkNTIxRidGRUZndS1GXXY2JVEnbGFtM3gyRidGYHZGYnZGRUZFRmRzLUYsNiYtRiM2KS1GIzYnLUYjNiYtRl12NiVRJ2xhbTF4MUYnRmB2RmJ2RmR2Rlx2RkUtRmVzNi1RIj1GJ0ZFRmhzRmp1Rlx0Rl50RmB0RmJ0RmR0L0ZndFEsMC4yNzc3Nzc4ZW1GJy9GanRGZHlGVkZgcUZFRmRzLUYjNictRiM2Ji1GXXY2JVEnbGFtMngxRidGYHZGYnZGZHZGYndGRUZgeUZWRmBxRkVGZHMtRiM2Jy1GIzYoLUZddjYlUSdsYW0zeDFGJ0ZgdkZidkZkdkZieEZkdkZqd0ZFRmB5RlZGYHFGRUZgcUZFRkUvRmRxUSJ8ZnJGJy9GZ3FRInxockYnRmRzLUZddjYlUSh2ZXJ0bGhzRidGYHZGYnZGZHMtRkI2JFEiN0YnRkVGYHFGRUZFRmNxRmZxRmRzLUYsNiYtRi82NS1GMjYnLUY1NigtRiM2JS1GZXM2LVEqJnVtaW51czA7RidGRUZoc0ZqdUZcdEZedEZgdEZidEZkdEZndkZpdi1GQjYkUS4wLjA1ODUwMDAwMDAwRidGRUZFRkhGS0ZNRk9GUi1GNTYoLUYjNiVGaFtsLUZCNiRRLjAuMDI5NzAwMDAwMDBGJ0ZFRkVGSEZLRk1GT0ZSRkhGS0ZNRlpGZ25GYnNGW29GXW9GYG9GY29GZW9GaG9GW3BGXnBGYHBGYnBGZXBGaHBGanBGXHFGXnFGRUZjcUZmcUZgcUZF">NiY9NiI2IzsiIiIiIiRFXFtsJEYnPUYkNiQ7RiciIiNGLEVcW2wlNiRGJ0YtRic2JEYnRiciIiE2JEYtRidGMTYkRi1GLUYxRi09RiRGK0VcW2wlRi9GMUYwRjFGMkYxRjNGJ0YoPUYkNiRGLEYmRVxbbCc2JEYnRihGLUYvRjFGMEYxRjJGMUYzRic2JEYtRihGMUYjNyYsLEknbGFtMXgyR0YkIiRzKCIlJ28iRidJJ2xhbTJ4MkdGJCIkbSNJJ2xhbTN4M0dGJCIlMzlJJ2xhbTN4MkdGJCIkQCY8JS8sJkknbGFtMXgxR0YkRidGPUYnRicvLCZJJ2xhbTJ4MUdGJEYnRkBGJ0YnLywoSSdsYW0zeDFHRiRGJ0ZERidGQkYnRidJKHZlcnRsaHNHRiQiIihJJmRlbHRhR0Yk</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`  maximum coordinates`, array( 1 .. 2, [( 1 ) = (3), ( 2 ) = (2)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5850000000e-1,(2, 1)=.2970000000e-1])
   obj.fnc=772*lam1x2+1686+266*lam2x2+1408*lam3x3+521*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5850000000e-1, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .2970000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKysrNSEiKi9JJ2xhbTF4MkdGJCQiIiFGLi9JJ2xhbTJ4MUdGJCQiKysrKy4oKiEjNS9JJ2xhbTJ4MkdGJCQiKysrK3FIISM2L0knbGFtM3gxR0YkJCIrKytdMigqRjMvSSdsYW0zeDJHRiRGLS9JJ2xhbTN4M0dGJCQiKysrK0RIRjg=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIxRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMEYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR0ZTLyUrY29sdW1uc3BhbkdGU0Zib0Zlb0Znb0Zpbi8lJmFsaWduR1ElYXhpc0YnL0Zjb1EpYmFzZWxpbmVGJy9GZm9RJnJpZ2h0RicvRmhvUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGMS8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRmpwLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRmVxLyUmZnJhbWVHRmVxLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGPS8lLWVxdWFsY29sdW1uc0dGPS8lLWRpc3BsYXlzdHlsZUdGPS8lJXNpZGVHRmNwLyUwbWlubGFiZWxzcGFjaW5nR0ZicS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRidGOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRjUtRiw2JVEqZXhwcmVzc2VkRidGL0YyRjUtRlg2Ji1GZ242NS1Gam42KC1GXW82KEZQRmJvRmVvRmdvRmlvRltwRlxvRlxvRmJvRmVvRmdvRl1wRmBwL0Zmb1EnY2VudGVyRidGZHBGZnBGaHBGW3FGXXFGYHFGY3FGZnFGaHFGanFGXXJGX3JGYXJGY3JGZXJGOUZqckZdc0ZnckY5">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiJJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 1, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (0), ( 2, 1 ) = (0)  ] ), array( 1 .. 3, [( 1 ) = (1), ( 2 ) = (0), ( 3 ) = (0)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=1.058500000,(2, 1)=.2970000000e-1])
   obj.fnc=772*lam1x2+1686+266*lam2x2+1408*lam3x3+521*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = 1.058500000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .2970000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIiIiIiIhL0knbGFtMXgyR0YkJEYqRiovSSdsYW0yeDFHRiQkIisrKysuKCohIzUvSSdsYW0yeDJHRiQkIisrKytxSCEjNi9JJ2xhbTN4MUdGJCQiKysrXTJaRjIvSSdsYW0zeDJHRiRGLS9JJ2xhbTN4M0dGJCQiKysrXSNIJkYy</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIyRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMUYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR0Zhby8lK2NvbHVtbnNwYW5HRmFvRmJvRmVvRmdvLUZqbjYmLUZdbzYoLUZRNiRRIjBGJ0Y5RmJvRmVvRmdvRmlvRltwRmJvRmVvRmdvLyUmYWxpZ25HUSVheGlzRicvRmNvUSliYXNlbGluZUYnL0Zmb1EmcmlnaHRGJy9GaG9RJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YxLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGYXEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGXHIvJSZmcmFtZUdGXHIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y9LyUtZXF1YWxjb2x1bW5zR0Y9LyUtZGlzcGxheXN0eWxlR0Y9LyUlc2lkZUdGanAvJTBtaW5sYWJlbHNwYWNpbmdHRmlxLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGNS1GLDYlUSpleHByZXNzZWRGJ0YvRjJGNS1GWDYmLUZnbjY1LUZqbjYoRlxvRl9wRl9wRmJvRmVvRmdvRmRwRmdwL0Zmb1EnY2VudGVyRidGW3FGXXFGX3FGYnFGZHFGZ3FGanFGXXJGX3JGYXJGZHJGZnJGaHJGanJGXHNGOUZhc0Zkc0Zec0Y5">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiNJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 1, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (1), ( 2, 1 ) = (0)  ] ), array( 1 .. 3, [( 1 ) = (1), ( 2 ) = (0), ( 3 ) = (0)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=2.058500000,(2, 1)=.2970000000e-1])
   obj.fnc=772*lam1x2+1686+266*lam2x2+1408*lam3x3+521*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = 2.058500000, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = .2970000000e-1, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKys6JSohIzUvSSdsYW0xeDJHRiQkIisrKytdZSEjNi9JJ2xhbTJ4MUdGJCQiKysrKy4oKkYqL0knbGFtMngyR0YkJCIrKysrcUhGLy9JJ2xhbTN4MUdGJCQiIiFGOy9JJ2xhbTN4MkdGJEY6L0knbGFtM3gzR0YkJCIrKysrKzUhIio=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSIzRidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMkYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGW3BGYm9GZW9GZ28tRmpuNiYtRl1vNigtRlE2JFEiMEYnRjlGYm9GZW9GZ29GaW9GXHBGYm9GZW9GZ28vJSZhbGlnbkdRJWF4aXNGJy9GY29RKWJhc2VsaW5lRicvRmZvUSZyaWdodEYnL0Zob1EnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHRjEvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0ZicS8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0Zdci8lJmZyYW1lR0Zdci8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHRj0vJS1lcXVhbGNvbHVtbnNHRj0vJS1kaXNwbGF5c3R5bGVHRj0vJSVzaWRlR0ZbcS8lMG1pbmxhYmVsc3BhY2luZ0dGanEvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnRjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Y1LUYsNiVRKmV4cHJlc3NlZEYnRi9GMkY1LUZYNiYtRmduNjUtRmpuNihGYHBGYHAtRl1vNihGUEZib0Zlb0Znb0Zpb0ZccEZib0Zlb0Znb0ZlcEZocC9GZm9RJ2NlbnRlckYnRlxxRl5xRmBxRmNxRmVxRmhxRltyRl5yRmByRmJyRmVyRmdyRmlyRltzRl1zRjlGYnNGZXNGX3NGOQ==">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiRJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 3, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (2), ( 2, 1 ) = (0)  ] ), array( 1 .. 3, [( 1 ) = (0), ( 2 ) = (0), ( 3 ) = (3)  ] )
Calling minimize() with: lifD=3, Opt_verts=array(1 .. 2, 1 .. 1,[(1, 1)=.5850000000e-1,(2, 1)=1.029700000])
   obj.fnc=772*lam1x2+1686+266*lam2x2+1408*lam3x3+521*lam3x2, eqns={lam1x1+lam1x2 = 1, lam1x2+2*lam3x3 = .5850000000e-1, lam2x1+lam2x2 = 1, lam2x2+lam3x2 = 1.029700000, lam3x1+lam3x2+lam3x3 = 1}</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output">NiRJKW9idGFpbmVkRzYiPCkvSSdsYW0xeDFHRiQkIisrKysrNSEiKi9JJ2xhbTF4MkdGJCQiIiFGLi9JJ2xhbTJ4MUdGJEYtL0knbGFtMngyR0YkRigvSSdsYW0zeDFHRiQkIisrK101JSohIzUvSSdsYW0zeDJHRiQkIisrKytxSCEjNi9JJ2xhbTN4M0dGJCQiKysrK0RIRjw=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUkjbWlHRiQ2JVFAdG9yaWMvY29tcF9yb3dzXzI6flJvd35tb25vbWlhbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictSSNtbkdGJDYkUSI0RidGOUY1LUYsNiVRJ2VxdWFsc0YnRi9GMkY1LUkobWZlbmNlZEdGJDYmLUYjNiUtSSdtdGFibGVHRiQ2Ni1JJG10ckdGJDYmLUkkbXRkR0YkNigtRlE2JFEiMEYnRjkvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRmRvLyUrZ3JvdXBhbGlnbkdGZG8vJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGW3BGYm9GZW9GZ28tRmpuNiYtRl1vNigtRlE2JEZbcEY5RmJvRmVvRmdvRmlvRlxwRmJvRmVvRmdvLyUmYWxpZ25HUSVheGlzRicvRmNvUSliYXNlbGluZUYnL0Zmb1EmcmlnaHRGJy9GaG9RJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0YxLyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGYXEvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGXHIvJSZmcmFtZUdGXHIvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Y9LyUtZXF1YWxjb2x1bW5zR0Y9LyUtZGlzcGxheXN0eWxlR0Y9LyUlc2lkZUdGanAvJTBtaW5sYWJlbHNwYWNpbmdHRmlxLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGNS1GLDYlUSpleHByZXNzZWRGJ0YvRjJGNS1GWDYmLUZnbjY1LUZqbjYoRmBwLUZdbzYoLUZRNiRRIjJGJ0Y5RmJvRmVvRmdvRmlvRlxwRlxvRmJvRmVvRmdvRmRwRmdwL0Zmb1EnY2VudGVyRidGW3FGXXFGX3FGYnFGZHFGZ3FGanFGXXJGX3JGYXJGZHJGZnJGaHJGanJGXHNGOUZhc0Zkc0Zec0Y5">NihJQHRvcmljL2NvbXBfcm93c18yOn5Sb3d+bW9ub21pYWxHNiIiIiVJJ2VxdWFsc0dGJEkjdnRHRiRJKmV4cHJlc3NlZEdGJEkpb3B0dmVydHNHRiQ=</Equation></Text-field>
</Output>
<Output>
<Text-field style="Line Printed Output" layout="Line Printed Output">`values of imax,vt,overts equal`, 2, array( 1 .. 2, 1 .. 1, [( 1, 1 ) = (0), ( 2, 1 ) = (1)  ] ), array( 1 .. 3, [( 1 ) = (1), ( 2 ) = (2), ( 3 ) = (0)  ] )
toric/mixed(): constructing 4-dim matrix
Subdivision resultant matrix of size 4 x 4.
timings[secs] and percents:
optimize=0.s ( 0%), find rows=.15e-1s (100%),construct=0.s ( 0%), total=.15e-1s
mixed returning [numM,denM],[pts,RC],supps,diagMons,denom_rows</Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYpLUYjNiYtRiw2JS1JJ210YWJsZUdGJDY4LUkkbXRyR0YkNiktSSRtdGRHRiQ2KC1GLDYmLUYsNiQtSShtc3Vic3VwR0YkNictSSNtaUdGJDYlUSJ1RicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUYsNiUtRkM2JVEiaUYnRkZGSS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvRkpRJ25vcm1hbEYnLUkjbW5HRiQ2JFEiMkYnRlQvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLyUvc3Vic2NyaXB0c2hpZnRHRmZuRlQtSSNtb0dGJDYtUSIrRidGVC8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGX28vJSlzdHJldGNoeUdGX28vJSpzeW1tZXRyaWNHRl9vLyUobGFyZ2VvcEdGX28vJS5tb3ZhYmxlbGltaXRzR0Zfby8lJ2FjY2VudEdGX28vJSdsc3BhY2VHUSwwLjIyMjIyMjJlbUYnLyUncnNwYWNlR0ZecC1JJW1zdWJHRiQ2JUZCLUYsNiUtRiw2JkZORmluLUZXNiRRIjFGJ0ZURlRGUUZURmduRlQvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRl1xLyUrZ3JvdXBhbGlnbkdGXXEvJShyb3dzcGFuR0ZqcC8lK2NvbHVtbnNwYW5HRmpwLUY5NigtRlc2JEZmbkZURltxRl5xRmBxRmJxRmRxLUY5NigtRiw2Ji1Gam42LVEqJnVtaW51czA7RidGVEZdb0Zgb0Zib0Zkb0Zmb0Zob0Zqb0ZccEZfcC1GLDYmRlYtRmpuNi1RMSZJbnZpc2libGVUaW1lcztGJ0ZURl1vRmBvRmJvRmRvRmZvRmhvRmpvL0ZdcFEmMC4wZW1GJy9GYHBGZ3ItRmJwNiVGQkZMRmduRlRGUUZURltxRl5xRmBxRmJxRmRxRmZxRltxRl5xRmBxLUY2NiktRjk2KC1GLDYmLUYsNiQtRkA2J0ZCRmRwRlZGWkZnbkZURmluLUZicDYlRkItRiw2JS1GLDYmRk5GaW5GVkZURlFGVEZnbkZURltxRl5xRmBxRmJxRmRxLUY5NigtRiw2JkZeci1GLDYmRlZGY3JGYXBGVEZRRlRGW3FGXnFGYHFGYnFGZHFGZnFGZnFGW3FGXnFGYHEtRjY2KUZmcUZmcUY4RmpxRltxRl5xRmBxLUY2NiktRjk2KC1GLDYmRl5yRj1GUUZURltxRl5xRmBxRmJxRmRxLUY5NihGaHBGW3FGXnFGYHFGYnFGZHFGZnEtRjk2KC1GLDYlRl5yRmhwRlRGW3FGXnFGYHFGYnFGZHFGW3FGXnFGYHEvJSZhbGlnbkdRJWF4aXNGJy9GXHFRKWJhc2VsaW5lRicvRl9xUSdjZW50ZXJGJy9GYXFRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0ZILyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGXHYvJStyb3dzcGFjaW5nR1EmMS4wZXhGJy8lLmNvbHVtbnNwYWNpbmdHUSYwLjhlbUYnLyUpcm93bGluZXNHUSVub25lRicvJSxjb2x1bW5saW5lc0dGZ3YvJSZmcmFtZUdGZ3YvJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0Zfby8lLWVxdWFsY29sdW1uc0dGX28vJS1kaXNwbGF5c3R5bGVHRl9vLyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRmR2RlFGVEZULyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnLUZqbjYtUSIsRidGVEZdby9GYW9GSEZib0Zkb0Zmb0Zob0Zqb0Zmci9GYHBRLDAuMzMzMzMzM2VtRictRmJwNiUtRkM2JVEoc3BlY01hdEYnRkZGSS1GLDYlRlZGUUZURmduRmB4LUYjNiYtRiw2Ky1GIzYmLUYsNiUtRjM2Ni1GNjYmRmZxRltxRl5xRmBxRmd5Rl91RmJ1L0ZfcUZnd0ZmdUZodUZqdUZddkZfdkZidkZldkZodkZqdkZcd0Zfd0Zhd0Zjd0Zld0Zod0ZRRlRGVEZqd0ZdeEZgeC1GIzYmLUYsNiUtRjM2NkZneS1GNjYmRml0RltxRl5xRmBxRl91RmJ1Rml5RmZ1Rmh1Rmp1Rl12Rl92RmJ2RmV2Rmh2Rmp2Rlx3Rl93RmF3RmN3RmV3Rmh3RlFGVEZURmp3Rl14RmB4LUYjNiYtRiw2JS1GMzY2RmB6Rmd5Rl91RmJ1Rml5RmZ1Rmh1Rmp1Rl12Rl92RmJ2RmV2Rmh2Rmp2Rlx3Rl93RmF3RmN3RmV3Rmh3RlFGVEZURmp3Rl14RmB4LUYjNiYtRiw2JS1GMzY2LUY2NiYtRjk2KEZWRltxRl5xRmBxRmJxRmRxRltxRl5xRmBxRmd5Rl91RmJ1Rml5RmZ1Rmh1Rmp1Rl12Rl92RmJ2RmV2Rmh2Rmp2Rlx3Rl93RmF3RmN3RmV3Rmh3RlFGVEZURmp3Rl14RlFGVEZURmp3Rl14RlFGVEZURmp3Rl14">NyU9NiI2JDsiIiIiIiVGJkVcW2wxNiQiIiQiIiMiIiE2JEYrRissJiokJkkidUdGJDYjSSJpR0YkRixGJyZGMjYjLCZGNEYnRidGJ0YnNiRGKEYsRic2JEYoRitGLTYkRihGJywkRjAhIiI2JEYrRigsJEYxISIjNiRGJ0YrRj42JEYnRixGLTYkRidGJ0YvNiRGLEYoRi02JEYsRicsJiokRjVGLEYnJkYyNiMsJkY0RidGLEYnRic2JEYsRiwsJEY1Rj82JEYnRihGLTYkRihGKEY8NiRGLEYrRi02JEYrRidGLSZJKHNwZWNNYXRHRiQ2I0YsNyY9RiQ2JDtGJ0YsO0YnRidFXFtsI0ZCRi1GREYtPUYkRlVFXFtsI0ZCRi1GREYnPUYkRlVFXFtsI0ZCRidGREYtPUYkRlVFXFtsI0ZCRixGREYt</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L20" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">aa:=Matrix(4, 4, {(1, 1) = u[i]^2+u[i+1], (1, 2) = 0, (1, 3) = -2*u[i], (1, 4) = 0, (2, 1) = u[i+1]^2+u[i+2], (2, 2) = -2*u[i+1], (2, 3) = 0, (2, 4) = 0, (3, 1) = 0, (3, 2) = 0, (3, 3) = u[i]^2+u[i+1], (3, 4) = -2*u[i], (4, 1) = -u[i]^2, (4, 2) = 1, (4, 3) = 0, (4, 4) = -1});</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbWlHRiQ2JVEjYWFGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSM6PUYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUkobWFjdGlvbkdGJDYlLUkobWZlbmNlZEdGJDYoLUYjNiUtSSdtdGFibGVHRiQ2OC1JJG10ckdGJDYpLUkkbXRkR0YkNigtRiM2Ji1GIzYkLUkobXN1YnN1cEdGJDYnLUYsNiVRInVGJ0YvRjItRiM2JS1GLDYlUSJpRidGL0YyLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJ0Y5LUkjbW5HRiQ2JFEiMkYnRjkvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLyUvc3Vic2NyaXB0c2hpZnRHRmJwRjktRjY2LVEiK0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EsMC4yMjIyMjIyZW1GJy9GTkZpcC1JJW1zdWJHRiQ2JUZhby1GIzYlLUYjNiZGZm9GZXAtRl1wNiRRIjFGJ0Y5RjlGaW9GOUZjcEY5LyUpcm93YWxpZ25HUSFGJy8lLGNvbHVtbmFsaWduR0ZncS8lK2dyb3VwYWxpZ25HRmdxLyUocm93c3BhbkdGZHEvJStjb2x1bW5zcGFuR0ZkcS1GaG42KC1GXXA2JEZicEY5RmVxRmhxRmpxRlxyRl5yLUZobjYoLUYjNiYtRjY2LVEqJnVtaW51czA7RidGOUY7Rj5GQEZCRkRGRkZIRmhwRmpwLUYjNiZGXHAtRjY2LVExJkludmlzaWJsZVRpbWVzO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTkZhcy1GXHE2JUZhb0Zkb0ZjcEY5RmlvRjlGZXFGaHFGanFGXHJGXnJGYHJGZXFGaHFGanEtRmVuNiktRmhuNigtRiM2Ji1GIzYkLUZfbzYnRmFvRl5xRlxwRmBwRmNwRjlGZXAtRlxxNiVGYW8tRiM2JS1GIzYmRmZvRmVwRlxwRjlGaW9GOUZjcEY5RmVxRmhxRmpxRlxyRl5yLUZobjYoLUYjNiZGaHItRiM2JkZccEZdc0ZbcUY5RmlvRjlGZXFGaHFGanFGXHJGXnJGYHJGYHJGZXFGaHFGanEtRmVuNilGYHJGYHJGZ25GZHJGZXFGaHFGanEtRmVuNiktRmhuNigtRiM2JkZockZcb0Zpb0Y5RmVxRmhxRmpxRlxyRl5yLUZobjYoRmJxRmVxRmhxRmpxRlxyRl5yRmByLUZobjYoLUYjNiVGaHJGYnFGOUZlcUZocUZqcUZcckZeckZlcUZocUZqcS8lJmFsaWduR1ElYXhpc0YnL0ZmcVEpYmFzZWxpbmVGJy9GaXFRJ2NlbnRlckYnL0ZbclEnfGZybGVmdHxockYnLyUvYWxpZ25tZW50c2NvcGVHRjEvJSxjb2x1bW53aWR0aEdRJWF1dG9GJy8lJndpZHRoR0Zmdi8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0Zhdy8lJmZyYW1lR0Zhdy8lLWZyYW1lc3BhY2luZ0dRLDAuNGVtfjAuNWV4RicvJSplcXVhbHJvd3NHRj0vJS1lcXVhbGNvbHVtbnNHRj0vJS1kaXNwbGF5c3R5bGVHRj0vJSVzaWRlR1EmcmlnaHRGJy8lMG1pbmxhYmVsc3BhY2luZ0dGXndGaW9GOUY5L0krbXNlbWFudGljc0dGJFEnTWF0cml4RicvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGZHgvJSthY3Rpb250eXBlR1EucnRhYmxlYWRkcmVzc0YnLyUpcnRhYmxlaWRHUTUxODQ0Njc0NDA3Mzg5Mzk2MjkyNkYnRmlvRjk=">LUknTWF0cml4RzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiMvSSQlaWRHRiciNUVIJ1IqUTJXblc9</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L24" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="simplify(det(aa));" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEpc2ltcGxpZnlGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSShtZmVuY2VkR0YkNiQtRiM2Jy1GLDYlUSRkZXRGJ0YvRjItRjY2JC1GIzYmLUYsNiVRI2FhRidGL0YyLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lK2V4ZWN1dGFibGVHUSZmYWxzZUYnL0YzUSdub3JtYWxGJ0ZKRkRGR0ZKRkotSSNtb0dGJDYtUSI7RidGSi8lJmZlbmNlR0ZJLyUqc2VwYXJhdG9yR0YxLyUpc3RyZXRjaHlHRkkvJSpzeW1tZXRyaWNHRkkvJShsYXJnZW9wR0ZJLyUubW92YWJsZWxpbWl0c0dGSS8lJ2FjY2VudEdGSS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjI3Nzc3NzhlbUYnRkRGR0ZK">QyQtSSlzaW1wbGlmeUc2JCUqcHJvdGVjdGVkR0koX3N5c2xpYkc2IjYjLUkkZGV0R0YoNiNJI2FhR0YoIiIi</Equation></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUYjNigtSSNtbkdGJDYkUSMxMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RMSZJbnZpc2libGVUaW1lcztGJ0YxLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkktSShtc3Vic3VwR0YkNictSSNtaUdGJDYlUSJ1RicvJSdpdGFsaWNHUSV0cnVlRicvRjJRJ2l0YWxpY0YnLUYjNiUtRlA2JVEiaUYnRlNGVi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRidGMS1GLjYkUSI0RidGMS8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRicvJS9zdWJzY3JpcHRzaGlmdEdGX29GNC1JJW1zdWJHRiQ2JUZPLUYjNiUtRiM2JkZaLUY1Ni1RIitGJ0YxRjhGO0Y9Rj9GQUZDRkUvRkhRLDAuMjIyMjIyMmVtRicvRktGXXAtRi42JFEiMUYnRjFGMUZnbkYxRmBvRjEtRjU2LVEoJm1pbnVzO0YnRjFGOEY7Rj1GP0ZBRkNGRUZccEZecC1GIzYoRmpuRjQtRk02J0ZPRlgtRi42JFEiMkYnRjFGXW9GYG9GNC1GY282JUZPLUYjNiUtRiM2JkZaRmlvRmlwRjFGZ25GMUZgb0YxRmlvLUYjNiZGaXBGNC1GTTYnRk9GZW8tRi42JFEiM0YnRjFGXW9GYG9GMUYx">LCgqJiZJInVHNiI2I0kiaUdGJiIiJSZGJTYjLCZGKCIiIkYtRi1GLSIjNSomRiQiIiMmRiU2IywmRihGLUYwRi1GLSEiJSokRioiIiRGMA==</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L25" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEhRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lK2V4ZWN1dGFibGVHUSZmYWxzZUYnL0YzUSdub3JtYWxGJw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYjLUkjbWlHRiQ2JVEhRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0Yn</Equation></Text-field>
</Input>
</Group><RTable handle="8446744073893962926">TTdSMApJQVJUQUJMRV9TQVZFLzE4NDQ2NzQ0MDczODkzOTYyOTI2WCwlKWFueXRoaW5nRzYiRiVbZ2whIiUhISEjMSIlIiV6JzYkJiUidUc2IyUiaUcmRik2IywmRisiIiJGL0YvW1tbW1tfW1tbW3NGL1xbW1tbW1tbW1tvRi96JzYkRiwmRik2IywmRitGLyIiI0YvW1tbW1tfW1tbW3NGL1xbW1tbW1tbW1tvRi8iIiEsJCokRihGNSEiIkY2LCRGLCEiI0Y2Ri8sJEYoRjtGNkYmRjZGNkY2RjxGOUYl</RTable>
</Worksheet>